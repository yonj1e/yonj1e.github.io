<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.2">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.2">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.2">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.2" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.2">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":true,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="Stay hungry, Stay young">
<meta name="keywords" content="blog, dbms, database, postgresql, pgsql, postgres, citus">
<meta property="og:type" content="website">
<meta property="og:title" content="Yonj1e&#39;s Blog">
<meta property="og:url" content="http:&#x2F;&#x2F;blog.yonj1e.top&#x2F;index.html">
<meta property="og:site_name" content="Yonj1e&#39;s Blog">
<meta property="og:description" content="Stay hungry, Stay young">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://blog.yonj1e.top/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Yonj1e's Blog</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Yonj1e's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">PostgreSQL Developer & DBA, @ksyun.com</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/yonj1e" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.yonj1e.top/2019/11/07/citus-append-distribution/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="Yang Jie">
      <meta itemprop="description" content="Stay hungry, Stay young">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yonj1e's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/07/citus-append-distribution/" class="post-title-link" itemprop="url">Citus中的分片策略：Append Distribution追加分配</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-07 00:00:00" itemprop="dateCreated datePublished" datetime="2019-11-07T00:00:00+00:00">2019-11-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-18 14:11:26" itemprop="dateModified" datetime="2020-07-18T14:11:26+00:00">2020-07-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Citus/" itemprop="url" rel="index">
                    <span itemprop="name">Citus</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://docs.citusdata.com/en/latest/develop/append.html" target="_blank" rel="noopener">https://docs.citusdata.com/en/latest/develop/append.html</a></p>
<p><a href="https://www.citusdata.com/blog/2016/12/15/citus-replication-model-today-and-tomorrow/" target="_blank" rel="noopener">https://www.citusdata.com/blog/2016/12/15/citus-replication-model-today-and-tomorrow/</a></p>
<blockquote>
<p>本文内容来自citus官方文档，包括一些原文翻译，简略介绍，使用示例等内容。</p>
</blockquote>
<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><blockquote>
<p>Append distribution is a specialized technique which requires care to use efficiently. Hash distribution is a better choice for most situations. </p>
<p>追加分配是一项需要谨慎有效使用的专门技术。对于大多数情况，散列分布是更好的选择。 </p>
</blockquote>
<p>While Citus’ most common use cases involve hash data distribution, it can also distribute timeseries data across a variable number of shards by their order in time. This section provides a short reference to loading, deleting, and manipulating timeseries data.</p>
<p>虽然Citus最常见的用例涉及散列数据分布，但它也可以按时间顺序将timeseries数据分布在数量可变的分片上。本节提供有关加载、删除和操作timeseries数据的简短参考。</p>
<p>As the name suggests, append based distribution is more suited to append-only use cases. This typically includes event based data which arrives in a time-ordered series. You can then distribute your largest tables by time, and batch load your events into Citus in intervals of N minutes. This data model can be generalized to a number of time series use cases; for example, each line in a website’s log file, machine activity logs or aggregated website events. Append based distribution supports more efficient range queries. This is because given a range query on the distribution key, the Citus query planner can easily determine which shards overlap that range and send the query only to relevant shards.</p>
<p>顾名思义，基于append的分布更适合仅追加的用例。这通常包括按时间顺序到达的基于事件的数据。然后可以按时间分布最大的表，并以N分钟为间隔将事件批量加载到Citus中。该数据模型可以推广到多个时间序列用例;例如，网站日志文件中的每一行、机器活动日志或聚合的网站事件。基于附加的分布支持更有效的范围查询。这是因为，给定分布键上的范围查询，Citus查询计划器可以很容易地确定哪些分片与该范围重叠，并只将查询发送到相关的分片。</p>
<p>Hash based distribution is more suited to cases where you want to do real-time inserts along with analytics on your data or want to distribute by a non-ordered column (eg. user id). This data model is relevant for real-time analytics use cases; for example, actions in a mobile application, user website events, or social media analytics. In this case, Citus will maintain minimum and maximum hash ranges for all the created shards. Whenever a row is inserted, updated or deleted, Citus will redirect the query to the correct shard and issue it locally. This data model is more suited for doing co-located joins and for queries involving equality based filters on the distribution column.</p>
<p>基于散列的分布更适合于这样的情况，即您希望执行实时插入并对数据进行分析，或者希望按无序列进行分布(例如。用户id)。这个数据模型与实时分析用例相关;例如，移动应用程序中的操作、用户网站事件或社交媒体分析。在这种情况下，Citus将为所有创建的分片维护最小和最大散列范围。无论何时插入、更新或删除一行，Citus都会将查询重定向到正确的分片，并在本地发出它。此数据模型更适合于在分布列上执行协同定位连接和涉及基于等式的过滤器的查询。</p>
<p>Citus uses slightly different syntaxes for creation and manipulation of append and hash distributed tables. Also, the operations supported on the tables differ based on the distribution method chosen. In the sections that follow, we describe the syntax for creating append distributed tables, and also describe the operations which can be done on them.</p>
<p>Citus在创建和操作append和散列分布式表时使用的语法略有不同。此外，根据所选择的分发方法，表上支持的操作也有所不同。在接下来的小节中，我们将描述用于创建append分布式表的语法，并描述可以对其进行的操作。</p>
<h2 id="Creating-and-Distributing-Tables"><a href="#Creating-and-Distributing-Tables" class="headerlink" title="Creating and Distributing Tables"></a>Creating and Distributing Tables</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> github_events</span><br><span class="line">(</span><br><span class="line">    event_id <span class="built_in">bigint</span>,</span><br><span class="line">    event_type <span class="built_in">text</span>,</span><br><span class="line">    event_public <span class="built_in">boolean</span>,</span><br><span class="line">    repo_id <span class="built_in">bigint</span>,</span><br><span class="line">    payload jsonb,</span><br><span class="line">    repo jsonb,</span><br><span class="line">    actor jsonb,</span><br><span class="line">    org jsonb,</span><br><span class="line">    created_at <span class="built_in">timestamp</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>Next, you can use the create_distributed_table() function to mark the  table as an append distributed table and specify its distribution  column. </p>
<p>接下来，可以使用create_distributed_table()函数将该表标记为追加分布式表并指定其分布列。 </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> create_distributed_table(<span class="string">'github_events'</span>, <span class="string">'created_at'</span>, <span class="string">'append'</span>);</span><br></pre></td></tr></table></figure>

<p>This function informs Citus that the github_events table should be  distributed by append on the created_at column. Note that this method  doesn’t enforce a particular distribution; it merely tells the database  to keep minimum and maximum values for the created_at column in each  shard which are later used by the database for optimizing queries. </p>
<p>该函数通知Citus, github_events表应该通过追加到created_at列上的方式分发。请注意，此方法并不强制执行特定的分发;它只是告诉数据库在每个分片中保留created_at列的最小值和最大值，稍后数据库将使用这些值来优化查询。 </p>
<h2 id="Expiring-Data"><a href="#Expiring-Data" class="headerlink" title="Expiring Data"></a>Expiring Data</h2><p>In append distribution, users typically want to track data only for  the last few months / years. In such cases, the shards that are no  longer needed still occupy disk space. To address this, Citus provides a user defined function master_apply_delete_command() to delete old  shards. The function takes a <a href="http://www.postgresql.org/docs/current/static/sql-delete.html" target="_blank" rel="noopener">DELETE</a> command as input and deletes all the shards that match the delete criteria with their metadata.</p>
<p>在append分发中，用户通常只想跟踪最近几个月/几年的数据。在这种情况下，不再需要的分片仍然占用磁盘空间。为了解决这个问题，Citus提供了一个用户定义的函数master_apply_delete_command()来删除旧分片。该函数以<a href="http://www.postgresql.org/docs/current/static/sql-delete.html" target="_blank" rel="noopener">DELETE</a>命令作为输入，并删除与删除条件匹配的所有分片及其元数据。 </p>
<p>The function uses shard metadata to decide whether or not a shard  needs to be deleted, so it requires the WHERE clause in the DELETE  statement to be on the distribution column. If no condition is  specified, then all shards are selected for deletion. The UDF then  connects to the worker nodes and issues DROP commands for all the shards which need to be deleted. If a drop query for a particular shard  replica fails, then that replica is marked as TO DELETE. The shard  replicas which are marked as TO DELETE are not considered for future  queries and can be cleaned up later.</p>
<p>该函数使用分片元数据来决定是否需要删除分片，因此它要求DELETE语句中的WHERE子句位于分布列上。如果没有指定任何条件，则选择删除所有分片。然后，UDF连接到工作节点，并发出删除所有需要删除的分片的命令。如果针对特定分片副本的drop查询失败，则该副本被标记为要删除。标记为要删除的shard副本不会考虑用于将来的查询，可以在以后进行清理。 </p>
<p>The example below deletes those shards from the github_events table  which have all rows with created_at &gt;= ‘2015-01-01 00:00:00’. Note  that the table is distributed on the created_at column.</p>
<p>下面的示例将从github_events表中删除那些包含created_at &gt;= ‘ 2015-01-01 00:00:00 ‘的所有行。注意，表分布在created_at列上。 </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> master_apply_delete_command(<span class="string">'DELETE FROM github_events WHERE created_at &gt;= ''2015-01-01 00:00:00'''</span>);</span><br><span class="line"> master_apply_delete_command</span><br><span class="line"><span class="comment">-----------------------------</span></span><br><span class="line">                           3</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>To learn more about the function, its arguments and its usage, please visit the <a href="https://docs.citusdata.com/en/latest/develop/api_udf.html#user-defined-functions" target="_blank" rel="noopener">Citus Utility Functions</a> section of our documentation.  Please note that this function only  deletes complete shards and not individual rows from shards. If your use case requires deletion of individual rows in real-time, see the section below about deleting data.</p>
<p>请注意，此函数只删除完整的分片，而不删除分片中的单个行。如果您的用例需要实时删除个别行，请参阅下面关于删除数据的部分。 </p>
<h2 id="Deleting-Data"><a href="#Deleting-Data" class="headerlink" title="Deleting Data"></a>Deleting Data</h2><p>The most flexible way to modify or delete rows throughout a Citus cluster with regular SQL statements:</p>
<p>最灵活的方式来修改或删除整个Citus集群的常规SQL语句行: </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> github_events</span><br><span class="line"><span class="keyword">WHERE</span> created_at &gt;= <span class="string">'2015-01-01 00:03:00'</span>;</span><br></pre></td></tr></table></figure>

<p>Unlike master_apply_delete_command, standard SQL works at the row-  rather than shard-level to modify or delete all rows that match the  condition in the where clause. It deletes rows regardless of whether  they comprise an entire shard.</p>
<p>与master_apply_delete_command不同，标准SQL在行上工作，而不是在分片级上修改或删除与where子句中的条件匹配的所有行。它删除行，不管它们是否包含整个分片。 </p>
<h2 id="Dropping-Tables"><a href="#Dropping-Tables" class="headerlink" title="Dropping Tables"></a>Dropping Tables</h2><p>You can use the standard PostgreSQL <a href="http://www.postgresql.org/docs/current/static/sql-droptable.html" target="_blank" rel="noopener">DROP TABLE</a> command to remove your append distributed tables. As with regular tables, DROP TABLE removes any indexes, rules, triggers, and constraints that exist for the target table. In addition, it also drops the shards on the worker nodes and cleans up their metadata.</p>
<p>可以使用标准的PostgreSQL <a href="http://www.postgresql.org/docs/current/static/sql-droptable.html" target="_blank" rel="noopener">DROP TABLE</a>命令删除附加的分布式表。与常规表一样，DROP表删除目标表的所有索引、规则、触发器和约束。此外，它还删除工作节点上的分片并清理它们的元数据。 </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> github_events;</span><br></pre></td></tr></table></figure>

<h2 id="Data-Loading"><a href="#Data-Loading" class="headerlink" title="Data Loading"></a>Data Loading</h2><p>Citus supports two methods to load data into your append distributed  tables. The first one is suitable for bulk loads from files and involves using the \copy command. For use cases requiring smaller, incremental  data loads, Citus provides two user defined functions. We describe each  of the methods and their usage below.</p>
<p>Citus支持两种方法来将数据加载到附加的分布式表中。第一种方法适用于从文件进行批量加载，并涉及到使用\copy命令。对于需要更小的增量数据负载的用例，Citus提供了两个用户定义的函数。我们将在下面描述每种方法及其用法。 </p>
<h3 id="Bulk-load-using-copy"><a href="#Bulk-load-using-copy" class="headerlink" title="Bulk load using \copy"></a>Bulk load using \copy</h3><p>The <a href="http://www.postgresql.org/docs/current/static/app-psql.html#APP-PSQL-META-COMMANDS-COPY" target="_blank" rel="noopener">\copy</a> command is used to copy data from a file to a distributed table while handling replication and failures automatically. You can also use the server side <a href="http://www.postgresql.org/docs/current/static/sql-copy.html" target="_blank" rel="noopener">COPY command</a>. In the examples, we use the \copy command from psql, which sends a COPY  .. FROM STDIN to the server and reads files on the client side, whereas  COPY from a file would read the file on the server.</p>
<p>[\copy](<a href="http://www.postgresql.org/docs/current/static/app-psql.html#" target="_blank" rel="noopener">http://www.postgresql.org/docs/current/static/app-psql.html#</a> app-psql - metadata - copy)命令用于将数据从文件复制到分布式表，同时自动处理复制和失败。您还可以使用服务器端<a href="http://www.postgresql.org/docs/current/static/sql-copy.html" target="_blank" rel="noopener">COPY命令</a>。在本例中，我们使用来自psql的\copy命令，它发送一个副本…从STDIN到服务器并读取客户端上的文件，而从文件复制则读取服务器上的文件。</p>
<p>You can use \copy both on the coordinator and from any of the  workers. When using it from the worker, you need to add the master_host  option. Behind the scenes, \copy first opens a connection to the  coordinator using the provided master_host option and uses  master_create_empty_shard to create a new shard. Then, the command  connects to the workers and copies data into the replicas until the size reaches shard_max_size, at which point another new shard is created.  Finally, the command fetches statistics for the shards and updates the  metadata.</p>
<p>您可以在协调节点和任何工作节点上使用\copy。当从工作节点中使用它时，您需要添加master_host选项。在后台，\copy首先使用提供的master_host选项打开到协调节点的连接，并使用master_create_empty_shard创建一个新的shard。然后，该命令连接到工作节点并将数据复制到副本中，直到大小达到shard_max_size，此时将创建另一个新分片。最后，该命令获取分片的统计信息并更新元数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> citus.shard_max_size <span class="keyword">TO</span> <span class="string">'64MB'</span>;</span><br><span class="line">\copy github_events from 'github_events-2015-01-01-0.csv' <span class="keyword">WITH</span> (<span class="keyword">format</span> CSV, master_host <span class="string">'coordinator-host'</span>)</span><br></pre></td></tr></table></figure>

<p>Citus assigns a unique shard id to each new shard and all its  replicas have the same shard id. Each shard is represented on the worker node as a regular PostgreSQL table with name ‘tablename_shardid’ where  tablename is the name of the distributed table and shardid is the unique id assigned to that shard. One can connect to the worker postgres  instances to view or run commands on individual shards.</p>
<p>Citus分配一个惟一的分片id到每个新分片及其所有副本具有相同的分片id。每个分片是工人代表节点作为常规PostgreSQL表名称的tablename_shardid分布表的表名是名字的和shardid是惟一的id分配到分片。可以连接到worker postgres实例来查看或运行单个分片上的命令。</p>
<p>By default, the \copy command depends on two configuration parameters for its behavior. These are called citus.shard_max_size and  citus.shard_replication_factor.</p>
<p>默认情况下，\copy命令的行为取决于两个配置参数。分别是：citus.shard_max_size 和citus.shard_replication_factor</p>
<ol>
<li><strong>citus.shard_max_size :-</strong> This parameter determines  the maximum size of a shard created using \copy, and defaults to 1 GB.  If the file is larger than this parameter, \copy will break it up into  multiple shards.</li>
<li>此参数确定使用\copy创建的分片的最大大小，默认为1 GB。如果文件比这个参数大，\copy将把它分成多个分片。 </li>
<li><strong>citus.shard_replication_factor :-</strong> This parameter  determines the number of nodes each shard gets replicated to, and  defaults to one. Set it to two if you want Citus to replicate data  automatically and provide fault tolerance. You may want to increase the  factor even higher if you run large clusters and observe node failures  on a more frequent basis.</li>
<li>该参数决定每个shard复制到的节点数量，默认为一个。如果希望Citus自动复制数据并提供容错，请将其设置为2。如果您运行大型集群并更频繁地观察节点故障，则可能希望进一步提高这个因素。 </li>
</ol>
<p>The configuration setting citus.shard_replication_factor can only be set on the coordinator node.</p>
<p>配置设置citus。shard_replication_factor只能在协调节点上设置。</p>
<p>Please note that you can load several files in parallel through  separate database connections or from different nodes. It is also worth  noting that \copy always creates at least one shard and does not append  to existing shards. You can use the method described below to append to  previously created shards.</p>
<p>请注意，您可以通过单独的数据库连接或从不同的节点并行加载多个文件。还值得注意的是，\copy总是创建至少一个切分，并且不会附加到现有的切分上。您可以使用下面描述的方法将之前创建的分片追加到后面。</p>
<p>There is no notion of snapshot isolation across shards, which means  that a multi-shard SELECT that runs concurrently with a COPY might see  it committed on some shards, but not on others. If the user is storing  events data, he may occasionally observe small gaps in recent data. It  is up to applications to deal with this if it is a problem (e.g.   exclude the most recent data from queries, or use some lock).</p>
<p>没有跨分片的快照隔离的概念，这意味着与一个副本并发运行的多分片选择可能会在一些分片上提交，而不是在其他分片上提交。如果用户正在存储事件数据，他可能会偶尔观察到最近数据中的小间隙。如果这是一个问题，则由应用程序来处理(例如，从查询中排除最近的数据，或使用一些锁)。</p>
<p>If COPY fails to open a connection for a shard placement then it behaves in the same way as INSERT, namely to mark the  placement(s) as inactive unless there are no more active placements. If  any other failure occurs after connecting, the transaction is rolled  back and thus no metadata changes are made.</p>
<p>如果复制无法为分片放置打开连接，那么它的行为与INSERT相同，即将放置标记为非活动的，除非没有更多的活动放置。如果连接后发生任何其他故障，则事务将回滚，因此不会对元数据进行更改。</p>
<h3 id="Incremental-loads-by-appending-to-existing-shards"><a href="#Incremental-loads-by-appending-to-existing-shards" class="headerlink" title="Incremental loads by appending to existing shards"></a>Incremental loads by appending to existing shards</h3><p>The \copy command always creates a new shard when it is used and is  best suited for bulk loading of data. Using \copy to load smaller data  increments will result in many small shards which might not be ideal. In order to allow smaller, incremental loads into append distributed  tables, Citus provides 2 user defined functions. They are  master_create_empty_shard() and master_append_table_to_shard().</p>
<p>当使用\copy命令时，它总是创建一个新的分片，并且最适合批量加载数据。使用\copy加载较小的数据增量将导致许多小分片，这可能不是理想的结果。为了允许向append分布式表中增加更小的负载，Citus提供了两个用户定义的函数。它们是master_create_empty_shard()和master_append_table_to_shard()。</p>
<p>master_create_empty_shard() can be used to create new empty shards  for a table. This function also replicates the empty shard to  citus.shard_replication_factor number of nodes like the \copy command.</p>
<p>master_create_empty_shard()可用于为表创建新的空分片。此函数还将空分片复制到citus。shard_replication_factor节点数，如\copy命令。</p>
<p>master_append_table_to_shard() can be used to append the contents of a PostgreSQL table to an existing shard. This allows the user to control  the shard to which the rows will be appended. It also returns the shard  fill ratio which helps to make a decision on whether more data should be appended to this shard or if a new shard should be created.</p>
<p>master_append_table_to_shard()可用于将PostgreSQL表的内容附加到现有的shard。这允许用户控制将附加行的分片。它还返回分片填充率，这有助于决定是否应该向这个分片添加更多的数据，还是应该创建一个新的分片。</p>
<p>To use the above functionality, you can first insert incoming data  into a regular PostgreSQL table. You can then create an empty shard  using master_create_empty_shard(). Then, using  master_append_table_to_shard(), you can append the contents of the  staging table to the specified shard, and then subsequently delete the  data from the staging table. Once the shard fill ratio returned by the  append function becomes close to 1, you can create a new shard and start appending to the new one.</p>
<p>要使用上述功能，您可以首先将传入的数据插入到常规的PostgreSQL表中。然后可以使用master_create_empty_shard()创建一个空分片。然后，使用master_append_table_to_shard()，可以将staging表的内容附加到指定的shard中，然后从staging表中删除数据。一旦append函数返回的分片填充比接近1，您就可以创建一个新的分片并开始将其附加到新的分片中。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> master_create_empty_shard(<span class="string">'github_events'</span>);</span><br><span class="line">master_create_empty_shard</span><br><span class="line"><span class="comment">---------------------------</span></span><br><span class="line">                102089</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> master_append_table_to_shard(<span class="number">102089</span>, <span class="string">'github_events_temp'</span>, <span class="string">'master-101'</span>, <span class="number">5432</span>);</span><br><span class="line">master_append_table_to_shard</span><br><span class="line"><span class="comment">------------------------------</span></span><br><span class="line">        0.100548</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>To learn more about the two UDFs, their arguments and usage, please visit the <a href="https://docs.citusdata.com/en/latest/develop/api_udf.html#user-defined-functions" target="_blank" rel="noopener">Citus Utility Functions</a> section of the documentation.</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><h3 id="Range-Based-Sharding"><a href="#Range-Based-Sharding" class="headerlink" title="Range Based Sharding"></a>Range Based Sharding</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">young=<span class="comment"># create table test(id int, ts timestamptz);</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span></span><br><span class="line">young=<span class="comment"># SELECT create_distributed_table('test', 'ts', 'append');</span></span><br><span class="line"><span class="keyword">NOTICE</span>:  <span class="keyword">using</span> <span class="keyword">statement</span>-based <span class="keyword">replication</span></span><br><span class="line">DETAIL:  Streaming <span class="keyword">replication</span> <span class="keyword">is</span> supported <span class="keyword">only</span> <span class="keyword">for</span> <span class="keyword">hash</span>-<span class="keyword">distributed</span> tables.</span><br><span class="line"> create_distributed_table </span><br><span class="line"><span class="comment">--------------------------</span></span><br><span class="line"> </span><br><span class="line">(<span class="number">1</span> <span class="keyword">row</span>)</span><br><span class="line"></span><br><span class="line">young=<span class="comment"># SELECT * from master_create_empty_shard('test');</span></span><br><span class="line"> master_create_empty_shard </span><br><span class="line"><span class="comment">---------------------------</span></span><br><span class="line">                    <span class="number">102046</span></span><br><span class="line">(<span class="number">1</span> <span class="keyword">row</span>)</span><br><span class="line"></span><br><span class="line">young=<span class="comment"># insert into test values (1, now());</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">young=<span class="comment"># table test ;</span></span><br><span class="line"> <span class="keyword">id</span> |              ts               </span><br><span class="line"><span class="comment">----+-------------------------------</span></span><br><span class="line">  <span class="number">1</span> | <span class="number">2019</span><span class="number">-11</span><span class="number">-07</span> <span class="number">15</span>:<span class="number">02</span>:<span class="number">23.850578</span>+<span class="number">08</span></span><br><span class="line">(<span class="number">1</span> <span class="keyword">row</span>)</span><br><span class="line"></span><br><span class="line">young=<span class="comment"># table pg_dist_shard;</span></span><br><span class="line"> logicalrelid | shardid | shardstorage | shardminvalue | shardmaxvalue </span><br><span class="line"><span class="comment">--------------+---------+--------------+---------------+---------------</span></span><br><span class="line"> <span class="keyword">test</span>         |  <span class="number">102046</span> | t            |               | </span><br><span class="line">(<span class="number">1</span> <span class="keyword">row</span>)</span><br><span class="line"></span><br><span class="line">young=<span class="comment"># insert into test values (2, now());</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">young=<span class="comment"># SELECT                             </span></span><br><span class="line">    n.nodename,</span><br><span class="line">    n.nodeport,</span><br><span class="line">    <span class="keyword">sum</span>(foo.result::int4)</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> *</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">        run_command_on_shards (<span class="string">'test'</span>,</span><br><span class="line">            <span class="string">'select count(*) from %s'</span>)) <span class="keyword">AS</span> foo,</span><br><span class="line">    pg_dist_placement p,</span><br><span class="line">    pg_dist_node n</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    foo.shardid = p.shardid</span><br><span class="line">    <span class="keyword">AND</span> p.groupid = n.groupid</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    n.nodename,</span><br><span class="line">    n.nodeport;</span><br><span class="line"> nodename | nodeport | sum </span><br><span class="line"><span class="comment">----------+----------+-----</span></span><br><span class="line"> 10.0.0.5 |     9432 |   2</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">young=<span class="comment"># SELECT * from master_create_empty_shard('test');</span></span><br><span class="line"> master_create_empty_shard </span><br><span class="line"><span class="comment">---------------------------</span></span><br><span class="line">                    102047</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">young=<span class="comment"># insert into test values (3, now());             </span></span><br><span class="line">ERROR:  cannot run <span class="keyword">INSERT</span> command which targets multiple shards</span><br><span class="line">HINT:  Make sure the <span class="keyword">value</span> <span class="keyword">for</span> <span class="keyword">partition</span> <span class="keyword">column</span> <span class="string">"ts"</span> falls <span class="keyword">into</span> a single shard.</span><br><span class="line">young=<span class="comment"># table pg_dist_shard;</span></span><br><span class="line"> logicalrelid | shardid | shardstorage | shardminvalue | shardmaxvalue </span><br><span class="line"><span class="comment">--------------+---------+--------------+---------------+---------------</span></span><br><span class="line"> <span class="keyword">test</span>         |  <span class="number">102046</span> | t            |               | </span><br><span class="line"> <span class="keyword">test</span>         |  <span class="number">102047</span> | t            |               | </span><br><span class="line">(<span class="number">2</span> <span class="keyword">rows</span>)</span><br><span class="line"></span><br><span class="line">young=<span class="comment"># select min(ts), max(ts) from test;</span></span><br><span class="line">              <span class="keyword">min</span>              |              <span class="keyword">max</span>              </span><br><span class="line"><span class="comment">-------------------------------+-------------------------------</span></span><br><span class="line"> <span class="number">2019</span><span class="number">-11</span><span class="number">-07</span> <span class="number">15</span>:<span class="number">02</span>:<span class="number">23.850578</span>+<span class="number">08</span> | <span class="number">2019</span><span class="number">-11</span><span class="number">-07</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">46.776405</span>+<span class="number">08</span></span><br><span class="line">(<span class="number">1</span> <span class="keyword">row</span>)</span><br><span class="line"></span><br><span class="line">young=<span class="comment"># update pg_dist_shard set shardminvalue = '2019-11-07 15:00:00', shardmaxvalue = '2019-11-07 15:04:59' where shardid = 102046;</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="number">1</span></span><br><span class="line">young=<span class="comment"># table pg_dist_shard;</span></span><br><span class="line"> logicalrelid | shardid | shardstorage |    shardminvalue    |    shardmaxvalue    </span><br><span class="line"><span class="comment">--------------+---------+--------------+---------------------+---------------------</span></span><br><span class="line"> <span class="keyword">test</span>         |  <span class="number">102047</span> | t            |                     | </span><br><span class="line"> <span class="keyword">test</span>         |  <span class="number">102046</span> | t            | <span class="number">2019</span><span class="number">-11</span><span class="number">-07</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">00</span> | <span class="number">2019</span><span class="number">-11</span><span class="number">-07</span> <span class="number">15</span>:<span class="number">04</span>:<span class="number">59</span></span><br><span class="line">(<span class="number">2</span> <span class="keyword">rows</span>)</span><br><span class="line"></span><br><span class="line">young=<span class="comment"># SELECT                                          </span></span><br><span class="line">    n.nodename,</span><br><span class="line">    n.nodeport,</span><br><span class="line">    <span class="keyword">sum</span>(foo.result::int4)</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> *</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">        run_command_on_shards (<span class="string">'test'</span>,</span><br><span class="line">            <span class="string">'select count(*) from %s'</span>)) <span class="keyword">AS</span> foo,</span><br><span class="line">    pg_dist_placement p,</span><br><span class="line">    pg_dist_node n</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    foo.shardid = p.shardid</span><br><span class="line">    <span class="keyword">AND</span> p.groupid = n.groupid</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    n.nodename,</span><br><span class="line">    n.nodeport;</span><br><span class="line"> nodename  | nodeport | sum </span><br><span class="line"><span class="comment">-----------+----------+-----</span></span><br><span class="line"> 10.0.0.5  |     9432 |   2</span><br><span class="line"> 10.0.0.10 |     9432 |   1</span><br><span class="line">(2 rows)</span><br><span class="line"></span><br><span class="line">young=<span class="comment"># update pg_dist_shard set shardminvalue = '2019-11-07 15:05:00', shardmaxvalue = '2019-11-07 15:09:59' where shardid = 102047;</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="number">1</span></span><br><span class="line">young=<span class="comment"># table pg_dist_shard;</span></span><br><span class="line"> logicalrelid | shardid | shardstorage |    shardminvalue    |    shardmaxvalue    </span><br><span class="line"><span class="comment">--------------+---------+--------------+---------------------+---------------------</span></span><br><span class="line"> <span class="keyword">test</span>         |  <span class="number">102046</span> | t            | <span class="number">2019</span><span class="number">-11</span><span class="number">-07</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">00</span> | <span class="number">2019</span><span class="number">-11</span><span class="number">-07</span> <span class="number">15</span>:<span class="number">04</span>:<span class="number">59</span></span><br><span class="line"> <span class="keyword">test</span>         |  <span class="number">102047</span> | t            | <span class="number">2019</span><span class="number">-11</span><span class="number">-07</span> <span class="number">15</span>:<span class="number">05</span>:<span class="number">00</span> | <span class="number">2019</span><span class="number">-11</span><span class="number">-07</span> <span class="number">15</span>:<span class="number">09</span>:<span class="number">59</span></span><br><span class="line">(<span class="number">2</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>
<p>文档有介绍删除分片、删除数据及删除表，未介绍TRUNCATE</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">young=<span class="comment"># table pg_dist_shard;</span></span><br><span class="line"> logicalrelid | shardid | shardstorage |    shardminvalue    |    shardmaxvalue    </span><br><span class="line"><span class="comment">--------------+---------+--------------+---------------------+---------------------</span></span><br><span class="line"> test         |  102046 | t            | 2019-11-07 15:00:00 | 2019-11-07 15:04:59</span><br><span class="line"> test         |  102047 | t            | 2019-11-07 15:05:00 | 2019-11-07 15:09:59</span><br><span class="line">(2 rows)</span><br><span class="line">young=<span class="comment"># truncate test ;</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span></span><br><span class="line">young=<span class="comment"># table pg_dist_shard;</span></span><br><span class="line"> logicalrelid | shardid | shardstorage | shardminvalue | shardmaxvalue </span><br><span class="line"><span class="comment">--------------+---------+--------------+---------------+---------------</span></span><br><span class="line">(<span class="number">0</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>



<h3 id="Directory-Based-Sharding"><a href="#Directory-Based-Sharding" class="headerlink" title="Directory Based Sharding"></a>Directory Based Sharding</h3><p>这与基于范围的分片类似，但不是确定分片键的数据属于哪个范围，而是将每个键绑定到其自己的特定分片。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">young=<span class="comment"># create table list(id int, col text);</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span></span><br><span class="line">young=<span class="comment"># SELECT create_distributed_table('list', 'col', 'append');</span></span><br><span class="line"><span class="keyword">NOTICE</span>:  <span class="keyword">using</span> <span class="keyword">statement</span>-based <span class="keyword">replication</span></span><br><span class="line">DETAIL:  Streaming <span class="keyword">replication</span> <span class="keyword">is</span> supported <span class="keyword">only</span> <span class="keyword">for</span> <span class="keyword">hash</span>-<span class="keyword">distributed</span> tables.</span><br><span class="line"> create_distributed_table </span><br><span class="line"><span class="comment">--------------------------</span></span><br><span class="line"> </span><br><span class="line">(<span class="number">1</span> <span class="keyword">row</span>)</span><br><span class="line"></span><br><span class="line">young=<span class="comment"># select master_create_empty_shard('list');</span></span><br><span class="line"> master_create_empty_shard </span><br><span class="line"><span class="comment">---------------------------</span></span><br><span class="line">                    <span class="number">102052</span></span><br><span class="line">(<span class="number">1</span> <span class="keyword">row</span>)</span><br><span class="line"></span><br><span class="line">young=<span class="comment"># update pg_dist_shard set shardminvalue = 'beijing', shardmaxvalue = 'beijing' where shardid = 102052;</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="number">1</span></span><br><span class="line">young=<span class="comment"># table pg_dist_shard;</span></span><br><span class="line"> logicalrelid | shardid | shardstorage | shardminvalue | shardmaxvalue </span><br><span class="line"><span class="comment">--------------+---------+--------------+---------------+---------------</span></span><br><span class="line"> <span class="keyword">list</span>         |  <span class="number">102052</span> | t            | beijing       | beijing</span><br><span class="line">(<span class="number">1</span> <span class="keyword">row</span>)</span><br><span class="line"></span><br><span class="line">young=<span class="comment"># insert into list values (1, 'beijing');</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">young=<span class="comment"># insert into list values (2, 'hangzhou');</span></span><br><span class="line"><span class="keyword">ERROR</span>:  cannot run <span class="keyword">INSERT</span> command which targets <span class="keyword">no</span> shards</span><br><span class="line">HINT:  Make sure you have created a shard which can receive this <span class="keyword">partition</span> <span class="keyword">column</span> value.</span><br><span class="line">young=<span class="comment"># table list ;</span></span><br><span class="line"> <span class="keyword">id</span> |   <span class="keyword">col</span>   </span><br><span class="line"><span class="comment">----+---------</span></span><br><span class="line">  <span class="number">1</span> | beijing</span><br><span class="line">(<span class="number">1</span> <span class="keyword">row</span>)</span><br></pre></td></tr></table></figure>

<h3 id="bulk-load-using-copy"><a href="#bulk-load-using-copy" class="headerlink" title="bulk load using copy"></a>bulk load using copy</h3><p>大小达到shard_max_size，将创建另一个新分片</p>
<p>此示例中一个copy创建多个分片</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">young=<span class="comment"># show citus.shard_max_size ;</span></span><br><span class="line"> citus.shard_max_size </span><br><span class="line"><span class="comment">----------------------</span></span><br><span class="line"> 1GB</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">young=<span class="comment"># table pg_dist_shard;</span></span><br><span class="line"> logicalrelid | shardid | shardstorage | shardminvalue | shardmaxvalue </span><br><span class="line"><span class="comment">--------------+---------+--------------+---------------+---------------</span></span><br><span class="line">(0 rows)</span><br><span class="line"></span><br><span class="line">young=<span class="comment"># \copy github_events from '/data/citus/github_events-2015-01-01-0.csv' WITH (format CSV);</span></span><br><span class="line">COPY 7702</span><br><span class="line"></span><br><span class="line">young=<span class="comment"># SELECT                                                                                  </span></span><br><span class="line">    n.nodename,</span><br><span class="line">    n.nodeport,</span><br><span class="line">    sum(foo.result::int4)</span><br><span class="line">FROM (</span><br><span class="line">    <span class="keyword">SELECT</span> *</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">        run_command_on_shards (<span class="string">'github_events'</span>,</span><br><span class="line">            <span class="string">'select count(*) from %s'</span>)) <span class="keyword">AS</span> foo,</span><br><span class="line">    pg_dist_placement p,</span><br><span class="line">    pg_dist_node n</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    foo.shardid = p.shardid</span><br><span class="line">    <span class="keyword">AND</span> p.groupid = n.groupid</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    n.nodename,</span><br><span class="line">    n.nodeport;</span><br><span class="line"> nodename  | nodeport | sum  </span><br><span class="line"><span class="comment">-----------+----------+------</span></span><br><span class="line"> 10.0.0.20 |     9432 | 7702</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">young=<span class="comment"># table pg_dist_shard;</span></span><br><span class="line"> logicalrelid  | shardid | shardstorage |    shardminvalue    |    shardmaxvalue    </span><br><span class="line"><span class="comment">---------------+---------+--------------+---------------------+---------------------</span></span><br><span class="line"> github_events |  102053 | t            | 2015-01-01 00:00:00 | 2015-01-01 00:59:58</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">young=<span class="comment"># SET citus.shard_max_size TO '4MB';</span></span><br><span class="line"><span class="keyword">SET</span></span><br><span class="line">young=<span class="comment"># show citus.shard_max_size ;</span></span><br><span class="line"> citus.shard_max_size </span><br><span class="line"><span class="comment">----------------------</span></span><br><span class="line"> <span class="number">4</span>MB</span><br><span class="line">(<span class="number">1</span> <span class="keyword">row</span>)</span><br><span class="line"></span><br><span class="line">young=<span class="comment"># \copy github_events from '/data/citus/github_events-2015-01-01-1.csv' WITH (format CSV);</span></span><br><span class="line">COPY <span class="number">7427</span></span><br><span class="line">young=<span class="comment"># table pg_dist_shard;</span></span><br><span class="line"> logicalrelid  | shardid | shardstorage |    shardminvalue    |    shardmaxvalue    </span><br><span class="line"><span class="comment">---------------+---------+--------------+---------------------+---------------------</span></span><br><span class="line"> github_events |  <span class="number">102053</span> | t            | <span class="number">2015</span><span class="number">-01</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> | <span class="number">2015</span><span class="number">-01</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">59</span>:<span class="number">58</span></span><br><span class="line"> github_events |  <span class="number">102054</span> | t            | <span class="number">2015</span><span class="number">-01</span><span class="number">-01</span> <span class="number">01</span>:<span class="number">00</span>:<span class="number">00</span> | <span class="number">2015</span><span class="number">-01</span><span class="number">-01</span> <span class="number">01</span>:<span class="number">14</span>:<span class="number">55</span></span><br><span class="line"> github_events |  <span class="number">102055</span> | t            | <span class="number">2015</span><span class="number">-01</span><span class="number">-01</span> <span class="number">01</span>:<span class="number">14</span>:<span class="number">55</span> | <span class="number">2015</span><span class="number">-01</span><span class="number">-01</span> <span class="number">01</span>:<span class="number">27</span>:<span class="number">40</span></span><br><span class="line"> github_events |  <span class="number">102056</span> | t            | <span class="number">2015</span><span class="number">-01</span><span class="number">-01</span> <span class="number">01</span>:<span class="number">27</span>:<span class="number">40</span> | <span class="number">2015</span><span class="number">-01</span><span class="number">-01</span> <span class="number">01</span>:<span class="number">41</span>:<span class="number">02</span></span><br><span class="line"> github_events |  <span class="number">102057</span> | t            | <span class="number">2015</span><span class="number">-01</span><span class="number">-01</span> <span class="number">01</span>:<span class="number">41</span>:<span class="number">02</span> | <span class="number">2015</span><span class="number">-01</span><span class="number">-01</span> <span class="number">01</span>:<span class="number">56</span>:<span class="number">29</span></span><br><span class="line"> github_events |  <span class="number">102058</span> | t            | <span class="number">2015</span><span class="number">-01</span><span class="number">-01</span> <span class="number">01</span>:<span class="number">56</span>:<span class="number">29</span> | <span class="number">2015</span><span class="number">-01</span><span class="number">-01</span> <span class="number">01</span>:<span class="number">59</span>:<span class="number">59</span></span><br><span class="line">(<span class="number">6</span> <span class="keyword">rows</span>)</span><br><span class="line"></span><br><span class="line">young=<span class="comment"># SELECT              </span></span><br><span class="line">    n.nodename,</span><br><span class="line">    n.nodeport,</span><br><span class="line">    <span class="keyword">sum</span>(foo.result::int4)</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> *</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">        run_command_on_shards (<span class="string">'github_events'</span>,</span><br><span class="line">            <span class="string">'select count(*) from %s'</span>)) <span class="keyword">AS</span> foo,</span><br><span class="line">    pg_dist_placement p,</span><br><span class="line">    pg_dist_node n</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    foo.shardid = p.shardid</span><br><span class="line">    <span class="keyword">AND</span> p.groupid = n.groupid</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    n.nodename,</span><br><span class="line">    n.nodeport;</span><br><span class="line"> nodename  | nodeport | sum  </span><br><span class="line"><span class="comment">-----------+----------+------</span></span><br><span class="line"> 10.0.0.20 |     9432 | 9506</span><br><span class="line"> 10.0.0.5  |     9432 | 2300</span><br><span class="line"> 10.0.0.10 |     9432 | 1662</span><br><span class="line"> 10.0.0.21 |     9432 | 1661</span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure>

<h3 id="appending-to-existing-shards"><a href="#appending-to-existing-shards" class="headerlink" title="appending to existing shards"></a>appending to existing shards</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">young=<span class="comment"># create table test(id int , col int);</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span></span><br><span class="line">young=<span class="comment"># SELECT create_distributed_table('test', 'col', 'append');</span></span><br><span class="line"><span class="keyword">NOTICE</span>:  <span class="keyword">using</span> <span class="keyword">statement</span>-based <span class="keyword">replication</span></span><br><span class="line">DETAIL:  Streaming <span class="keyword">replication</span> <span class="keyword">is</span> supported <span class="keyword">only</span> <span class="keyword">for</span> <span class="keyword">hash</span>-<span class="keyword">distributed</span> tables.</span><br><span class="line"> create_distributed_table </span><br><span class="line"><span class="comment">--------------------------</span></span><br><span class="line"> </span><br><span class="line">(<span class="number">1</span> <span class="keyword">row</span>)</span><br><span class="line"></span><br><span class="line">young=<span class="comment"># create table tmp (id int, col int);</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span></span><br><span class="line">young=<span class="comment"># insert into tmp select id, id from generate_series(1,5) as id;</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="number">0</span> <span class="number">5</span></span><br><span class="line">young=<span class="comment"># table tmp ;</span></span><br><span class="line"> <span class="keyword">id</span> | <span class="keyword">col</span> </span><br><span class="line"><span class="comment">----+-----</span></span><br><span class="line">  <span class="number">1</span> |   <span class="number">1</span></span><br><span class="line">  <span class="number">2</span> |   <span class="number">2</span></span><br><span class="line">  <span class="number">3</span> |   <span class="number">3</span></span><br><span class="line">  <span class="number">4</span> |   <span class="number">4</span></span><br><span class="line">  <span class="number">5</span> |   <span class="number">5</span></span><br><span class="line">(<span class="number">5</span> <span class="keyword">rows</span>)</span><br><span class="line"></span><br><span class="line">young=<span class="comment"># select master_create_empty_shard('test');</span></span><br><span class="line"> master_create_empty_shard </span><br><span class="line"><span class="comment">---------------------------</span></span><br><span class="line">                    <span class="number">102059</span></span><br><span class="line">(<span class="number">1</span> <span class="keyword">row</span>)</span><br><span class="line"></span><br><span class="line">young=<span class="comment"># SELECT master_append_table_to_shard(102059, 'tmp', '10.0.0.4', 9432);</span></span><br><span class="line"> master_append_table_to_shard </span><br><span class="line"><span class="comment">------------------------------</span></span><br><span class="line">                   <span class="number">0.00195312</span></span><br><span class="line">(<span class="number">1</span> <span class="keyword">row</span>)</span><br><span class="line"></span><br><span class="line">young=<span class="comment"># table pg_dist_shard;</span></span><br><span class="line"> logicalrelid  | shardid | shardstorage |    shardminvalue    |    shardmaxvalue    </span><br><span class="line"><span class="comment">---------------+---------+--------------+---------------------+---------------------</span></span><br><span class="line"> <span class="keyword">test</span>          |  <span class="number">102059</span> | t            | <span class="number">1</span>                   | <span class="number">5</span></span><br><span class="line">(<span class="number">1</span> <span class="keyword">rows</span>)</span><br><span class="line"></span><br><span class="line">young=<span class="comment"># table test ;</span></span><br><span class="line"> <span class="keyword">id</span> | <span class="keyword">col</span> </span><br><span class="line"><span class="comment">----+-----</span></span><br><span class="line">  <span class="number">1</span> |   <span class="number">1</span></span><br><span class="line">  <span class="number">2</span> |   <span class="number">2</span></span><br><span class="line">  <span class="number">3</span> |   <span class="number">3</span></span><br><span class="line">  <span class="number">4</span> |   <span class="number">4</span></span><br><span class="line">  <span class="number">5</span> |   <span class="number">5</span></span><br><span class="line">(<span class="number">5</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>

<h3 id="other"><a href="#other" class="headerlink" title="other"></a>other</h3><p>ERROR:  cannot run INSERT command which targets multiple shards</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">cat test.csv </span><br><span class="line">1,1</span><br><span class="line">2,2</span><br><span class="line">3,3</span><br><span class="line">4,4</span><br><span class="line">5,5</span><br><span class="line"></span><br><span class="line">young=<span class="comment"># copy test from '/data/citus/test.csv' with csv;</span></span><br><span class="line">COPY 5</span><br><span class="line">young=<span class="comment"># table pg_dist_shard;</span></span><br><span class="line"> logicalrelid  | shardid | shardstorage |    shardminvalue    |    shardmaxvalue    </span><br><span class="line"><span class="comment">---------------+---------+--------------+---------------------+---------------------</span></span><br><span class="line"> test          |  102096 | t            | 1                   | 5</span><br><span class="line">(1 rows)</span><br><span class="line"></span><br><span class="line">cat test.csv </span><br><span class="line">7,7</span><br><span class="line">8,8</span><br><span class="line">young=<span class="comment"># copy test from '/data/citus/test.csv' with csv;</span></span><br><span class="line">COPY 2</span><br><span class="line">young=<span class="comment"># table pg_dist_shard;</span></span><br><span class="line"> logicalrelid  | shardid | shardstorage |    shardminvalue    |    shardmaxvalue    </span><br><span class="line"><span class="comment">---------------+---------+--------------+---------------------+---------------------</span></span><br><span class="line"> test          |  102096 | t            | 1                   | 5</span><br><span class="line"> test          |  102097 | t            | 7                   | 8</span><br><span class="line">(2 rows)</span><br><span class="line"></span><br><span class="line">cat test.csv </span><br><span class="line">8,8</span><br><span class="line">9,9</span><br><span class="line">young=<span class="comment"># copy test from '/data/citus/test.csv' with csv;</span></span><br><span class="line">COPY 2</span><br><span class="line">young=<span class="comment"># table pg_dist_shard;</span></span><br><span class="line"> logicalrelid  | shardid | shardstorage |    shardminvalue    |    shardmaxvalue    </span><br><span class="line"><span class="comment">---------------+---------+--------------+---------------------+---------------------</span></span><br><span class="line"> test          |  102096 | t            | 1                   | 5</span><br><span class="line"> test          |  102097 | t            | 7                   | 8</span><br><span class="line"> test          |  102098 | t            | 8                   | 9</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>

<p>shard_102097和shard_102098分区边界重合</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">young=<span class="comment"># SELECT</span></span><br><span class="line">    n.nodename,</span><br><span class="line">    n.nodeport,</span><br><span class="line">    sum(foo.result::int4)</span><br><span class="line">FROM (</span><br><span class="line">    <span class="keyword">SELECT</span> *</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">        run_command_on_shards (<span class="string">'test'</span>,</span><br><span class="line">            <span class="string">'select count(*) from %s'</span>)) <span class="keyword">AS</span> foo,</span><br><span class="line">    pg_dist_placement p,</span><br><span class="line">    pg_dist_node n</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    foo.shardid = p.shardid</span><br><span class="line">    <span class="keyword">AND</span> p.groupid = n.groupid</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    n.nodename,</span><br><span class="line">    n.nodeport;</span><br><span class="line"> nodename  | nodeport | sum </span><br><span class="line"><span class="comment">-----------+----------+-----</span></span><br><span class="line"> 10.0.0.20 |     9432 |   2</span><br><span class="line"> 10.0.0.5  |     9432 |   2</span><br><span class="line"> 10.0.0.21 |     9432 |   5</span><br><span class="line">(3 rows)</span><br><span class="line"></span><br><span class="line">young=<span class="comment"># insert into test values (8,8);</span></span><br><span class="line">ERROR:  cannot run <span class="keyword">INSERT</span> command which targets multiple shards</span><br><span class="line">HINT:  Make sure the <span class="keyword">value</span> <span class="keyword">for</span> <span class="keyword">partition</span> <span class="keyword">column</span> <span class="string">"col"</span> falls <span class="keyword">into</span> a single shard.</span><br></pre></td></tr></table></figure>



<p>ERROR:  INSERT … SELECT into an append-distributed table is not supported</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">young=<span class="comment"># table pg_dist_shard;</span></span><br><span class="line"> logicalrelid | shardid | shardstorage |    shardminvalue    |    shardmaxvalue    </span><br><span class="line"><span class="comment">--------------+---------+--------------+---------------------+---------------------</span></span><br><span class="line"> range        |  102050 | t            | 11                  | 15</span><br><span class="line"> range        |  102049 | t            | 6                   | 10</span><br><span class="line"> range        |  102048 | t            | 0                   | 5</span><br><span class="line">(3 rows)</span><br><span class="line"></span><br><span class="line">young=<span class="comment"># insert into range select id, id from generate_series(1,15) as id;</span></span><br><span class="line">ERROR:  <span class="keyword">INSERT</span> ... <span class="keyword">SELECT</span> <span class="keyword">into</span> an append-<span class="keyword">distributed</span> <span class="keyword">table</span> <span class="keyword">is</span> <span class="keyword">not</span> supported</span><br></pre></td></tr></table></figure>

<h2 id="replication-model"><a href="#replication-model" class="headerlink" title="replication model"></a>replication model</h2><p>以append方式建表时可以注意到</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NOTICE:  using statement-based replication</span><br><span class="line">DETAIL:  Streaming replication is supported only for hash-distributed tables.</span><br></pre></td></tr></table></figure>

<p>citus 有两种复制模式：基于语句复制、流复制</p>
<p>最初版本的citus主要用来做实时分析，数据也是通过追加方式存储在分布式集群中。</p>
<p>事件数据的这些属性使事件数据的并行加载变得相对容易，而不需要牺牲一致性语义。协调节点将保存与集群中的分片和分片放置(副本)相关的元数据。然后，客户机将与协调节点节点通信，并交换元数据，以便在这些元数据上附加事件数据分片。一旦客户端将相关事件数据附加到相关分片中，客户端将通过更新协调节点上的分片元数据来结束操作。</p>
<p> <img src="/2019/11/07/citus-append-distribution/citus-batch-append-event-527c025d.jpg" alt="Citus cluster ingesting append-only events data from files"> </p>
<p>上面的简化图显示了一个数据加载示例。客户端告诉协调节点节点，它希望将事件数据追加到追加分布式表中。协调节点向客户提供有关shard 6的位置信息。然后客户端将这些事件复制到分片的位置，并使用相关元数据更新协调节点。如果客户机无法将事件复制到其中一个节点，它可以将相关分片的位置标记为无效，也可以中止复制操作。</p>
<p>追加分配还存在一个问题是不能更新数据，上面已经做过测试。</p>
<p>因此，我们将Citus的基于语句的复制模型进行了扩展。 在该模型中，我们还提供了哈希分布作为一种数据分布方法。通过这种方式，用户可以轻松地更新和删除单独的行。启用更新和删除还需要解决两个问题:更新同一行的并发客户机，以及在更新期间一个shard副本不可用。 </p>
<p>因此，我们以两种方式扩展了协调节点。首先，协调节点处理涉及相同分片的update和delete语句的锁定。其次，如果协调节点在写操作期间无法到达分片副本，则会将该副本标记为不健康。然后，用户将运行一个命令来修复不健康的副本。</p>
<p>从一致性语义的角度来看，这种方法通常称为读写一致性（写后读一致性）。</p>
<p> <img src="/2019/11/07/citus-append-distribution/citus-insert-update-user-66fbd116.jpg" alt="Citus cluster receiving inserts and updates for user data and one shard placement becomes unavailable"> </p>
<p>假设您有200个表，如果并发更新了10个表的分片，但是无法到达保存分片副本的机器您需要将该机器上的所有200个分片副本标记为非活动的。</p>
<p>如果高可用性特性，那么基于语句的复制通常是不够好的。</p>
<p>解决方法之一是将 replication factor 设置为1，不使用副本。</p>
<p>另一种方案是从基于语句复制切换到流复制。</p>
<p>这种方法的架构如下：</p>
<p> <img src="/2019/11/07/citus-append-distribution/citus-streaming-replica-setup-04917fc2.jpg" alt="Citus serving multi-tenant applications using streaming replication"> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.yonj1e.top/2019/06/27/orderby-limit-index/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="Yang Jie">
      <meta itemprop="description" content="Stay hungry, Stay young">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yonj1e's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/27/orderby-limit-index/" class="post-title-link" itemprop="url">PostgreSQL中order by limit索引选择问题</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-27 00:00:00" itemprop="dateCreated datePublished" datetime="2019-06-27T00:00:00+00:00">2019-06-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-18 14:11:26" itemprop="dateModified" datetime="2020-07-18T14:11:26+00:00">2020-07-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/" itemprop="url" rel="index">
                    <span itemprop="name">PostgreSQL</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>相同sql，limit 1和limit 10，走不同索引，效率相差很大</p>
<p>实际执行计划如下:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">test=<span class="comment"># explain analyze select data_id from test_tbl where status=0 and city_id=310188 and type=103 and sub_type in(10306,10304,10305) order by create_time desc limit 1;</span></span><br><span class="line">                                                                                    QUERY PLAN                                                                                   </span><br><span class="line"><span class="comment">----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> Limit  (cost=0.44..1690.33 rows=1 width=16) (actual time=12816.268..12816.269 rows=1 loops=1)</span><br><span class="line">   -&gt;  Index Scan Backward using test_tbl_create_time_idx on test_tbl  (cost=0.44..1936615.36 rows=1146 width=16) (actual time=12816.266..12816.266 rows=1 loops=1)</span><br><span class="line">         Filter: ((status = 0) AND (city_id = 310188) AND (type = 103) AND (sub_type = ANY ('&#123;10306,10304,10305&#125;'::integer[])))</span><br><span class="line">         Rows Removed by Filter: 9969343</span><br><span class="line"> Planning time: 2.940 ms</span><br><span class="line"> Execution time: 12816.306 ms</span><br><span class="line">(6 rows)</span><br><span class="line"> </span><br><span class="line">test=<span class="comment"># explain analyze select data_id from test_tbl where status=0 and city_id=310188 and type=103 and sub_type in(10306,10304,10305) order by create_time desc limit 10;</span></span><br><span class="line">                                                                                      QUERY PLAN                                                                                     </span><br><span class="line"><span class="comment">--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> Limit  (cost=4268.71..4268.73 rows=10 width=16) (actual time=0.082..0.084 rows=10 loops=1)</span><br><span class="line">   -&gt;  Sort  (cost=4268.71..4271.57 rows=1146 width=16) (actual time=0.082..0.083 rows=10 loops=1)</span><br><span class="line">         Sort Key: create_time</span><br><span class="line">         Sort Method: quicksort  Memory: 25kB</span><br><span class="line">         -&gt;  Index Scan using test_tbl_city_id_sub_type_create_time_idx on test_tbl  (cost=0.44..4243.94 rows=1146 width=16) (actual time=0.030..0.066 rows=15 loops=1)</span><br><span class="line">               Index Cond: ((city_id = 310188) AND (sub_type = ANY ('&#123;10306,10304,10305&#125;'::integer[])))</span><br><span class="line"> Planning time: 0.375 ms</span><br><span class="line"> Execution time: 0.150 ms</span><br><span class="line">(8 rows)</span><br></pre></td></tr></table></figure>

<p>两个走的索引不一样</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">test=<span class="comment"># \d test_tbl_create_time_idx</span></span><br><span class="line">     Index "public.test_tbl_create_time_idx"</span><br><span class="line">   Column    |            Type             | Definition </span><br><span class="line"><span class="comment">-------------+-----------------------------+-------------</span></span><br><span class="line"> create_time | timestamp without time zone | create_time</span><br><span class="line">btree, for table "public.test_tbl"</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">test=<span class="comment"># \d test_tbl_city_id_sub_type_create_time_idx</span></span><br><span class="line">Index "public.test_tbl_city_id_sub_type_create_time_idx"</span><br><span class="line">   Column    |            Type             | Definition </span><br><span class="line"><span class="comment">-------------+-----------------------------+-------------</span></span><br><span class="line"> city_id     | integer                     | city_id</span><br><span class="line"> sub_type    | integer                     | sub_type</span><br><span class="line"> create_time | timestamp without time zone | create_time</span><br><span class="line">btree, for table "public.test_tbl", predicate (type = 103 AND status = 0)</span><br></pre></td></tr></table></figure>

<p>首先，表的记录数(3123万)除以满足whereclase的记录数(1199)，得到平均需要扫描多少条记录，可以得到一条满足whereclase条件的记录</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">test=<span class="comment"># select count(*) from test_tbl;</span></span><br><span class="line">  count  </span><br><span class="line"><span class="comment">----------</span></span><br><span class="line"> 31227936</span><br><span class="line">(1 row)</span><br><span class="line"> </span><br><span class="line">test=<span class="comment"># select 31227936/1199;</span></span><br><span class="line"> ?column?</span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">    26044</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>也就是说每扫描26044条记录，可以得到一条满足条件的记录。（优化器这么算，是认为数据分布是均匀的。）</p>
<p>但是，实际上，数据分布是不均匀的，whereclause的记录在表的前端。</p>
<p>并不是估算的每扫描26044条记录，可以得到一条满足条件的记录。</p>
<p>问题就出在这里。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ctid</span></span><br><span class="line">test=<span class="comment"># select max(ctid) from test_tbl;</span></span><br><span class="line">     max     </span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line"> (244118,407)</span><br><span class="line">(1 row)</span><br><span class="line"> </span><br><span class="line">test=<span class="comment"># select max(ctid),min(ctid) from test_tbl where data_id in (select data_id from test_tbl where status=0 and city_id=310188 and type=103 and sub_type in(10306,10304,10305));</span></span><br><span class="line">    max     |    min   </span><br><span class="line"><span class="comment">------------+-----------</span></span><br><span class="line"> (21293,15) | (2444,73)</span><br><span class="line">(1 row)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 分布在28w个rows里(不一定均匀分布),且通过数据分布分别在表中的 page min号 是 2444, max号是21293, 整个表的最大page号是 244118, 可以看出符合条件的28w行,物理分布于表的前端.</span></span><br><span class="line"> </span><br><span class="line">test=<span class="comment"># select 31227936/244118*21293;</span></span><br><span class="line"> ?column?</span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">  2704211</span><br><span class="line">(1 row)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># order by asc 就能看出效果</span></span><br><span class="line">test=<span class="comment"># explain analyze select data_id from test_tbl where status=0 and city_id=310188 and type=103 and sub_type in(10306,10304,10305) order by create_time asc limit 1;</span></span><br><span class="line">                                                                              QUERY PLAN                                                                              </span><br><span class="line"><span class="comment">-----------------------------------------------------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> Limit  (cost=0.44..1615.86 rows=1 width=16) (actual time=4295.865..4295.866 rows=1 loops=1)</span><br><span class="line">   -&gt;  Index Scan using test_tbl_create_time_idx on test_tbl  (cost=0.44..1936888.15 rows=1199 width=16) (actual time=4295.864..4295.864 rows=1 loops=1)</span><br><span class="line">         Filter: ((status = 0) AND (city_id = 310188) AND (type = 103) AND (sub_type = ANY ('&#123;10306,10304,10305&#125;'::integer[])))</span><br><span class="line">         Rows Removed by Filter: 4712758</span><br><span class="line"> Planning time: 0.404 ms</span><br><span class="line"> Execution time: 4295.884 ms</span><br><span class="line">(6 rows)</span><br></pre></td></tr></table></figure>

<h2 id="为什么走不同的索引"><a href="#为什么走不同的索引" class="headerlink" title="为什么走不同的索引"></a>为什么走不同的索引</h2><p>实际上PG会通过计算成本得到应该使用哪个索引</p>
<p>在limit10 时, 使用test_tbl_city_id_sub_type_create_time_idx索引的时候，需要扫描1199行，然后排序，总cost是 cost=4268.71..4271.57，然后取出 desc 的10个tuple,需要的cost是cost=4268.71..4268.73,</p>
<p>实际的执行时间是: actual time=0.082..0.084，从这点来看，limit 10 的真正执行时间比执行计划还快, 可以认为是查询规化器从诸多查询路径中，找到较优的执行计划了.</p>
<p>在 limit 1 时, 使用 test_tbl_create_time_idx的时候, </p>
<p>Limit (cost=0.44..1690.33 rows=1 width=16) (actual time=12816.268..12816.269 rows=1 loops=1)</p>
<p>执行计划预估是 cost=0.44..1690.33，但是实际却是 actual time=12816.268..12816.269,  明显查询规化器从诸多查询路径中，找到的执行计划不是较优的. 也就是查询规化器出现了误判.</p>
<p>返回多少条记录能达到4271.57成本（limit 1 cost 1690.33，limit 10 sort cost 4271.57）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test=<span class="comment"># select 4271.57/1690.33;</span></span><br><span class="line">      ?column?     </span><br><span class="line"><span class="comment">--------------------</span></span><br><span class="line"> 2.5270627628924530</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>limit 大于2.5的时候走 test_tbl_city_id_sub_type_create_time_idx 索引</p>
<p>limit 小于2.5的时候走  test_tbl_create_time_idx 索引</p>
<p>验证一下，也确实如此</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">test=<span class="comment">#  explain analyze select data_id from test_tbl where status=0 and city_id=310188 and type=103 and sub_type in(10306,10304,10305) order by create_time desc limit 3;</span></span><br><span class="line">                                                                                      QUERY PLAN                                             </span><br><span class="line">                                         </span><br><span class="line"><span class="comment">--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> Limit  (cost=4455.61..4455.62 rows=3 width=16) (actual time=0.103..0.103 rows=3 loops=1)</span><br><span class="line">   -&gt;  Sort  (cost=4455.61..4458.61 rows=1199 width=16) (actual time=0.103..0.103 rows=3 loops=1)</span><br><span class="line">         Sort Key: create_time</span><br><span class="line">         Sort Method: top-N heapsort  Memory: 25kB</span><br><span class="line">         -&gt;  Index Scan using test_tbl_city_id_sub_type_create_time_idx on test_tbl  (cost=0.44..4440.12 rows=1199 width=16) (ac</span><br><span class="line">tual time=0.047..0.088 rows=15 loops=1)</span><br><span class="line">               Index Cond: ((city_id = 310188) AND (sub_type = ANY ('&#123;10306,10304,10305&#125;'::integer[])))</span><br><span class="line"> Planning time: 0.413 ms</span><br><span class="line"> Execution time: 0.151 ms</span><br><span class="line">(8 rows)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">test=<span class="comment">#  explain analyze select data_id from test_tbl where status=0 and city_id=310188 and type=103 and sub_type in(10306,10304,10305) order by create_time desc limit 2;</span></span><br><span class="line">                                                                                    QUERY PLAN                                               </span><br><span class="line">                                     </span><br><span class="line"><span class="comment">----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> Limit  (cost=0.44..3231.28 rows=2 width=16) (actual time=11433.166..15947.713 rows=2 loops=1)</span><br><span class="line">   -&gt;  Index Scan Backward using test_tbl_create_time_idx on test_tbl  (cost=0.44..1936892.40 rows=1199 width=16) (actual time=11433.164..15947.708 rows=2 loops=1)</span><br><span class="line">         Filter: ((status = 0) AND (city_id = 310188) AND (type = 103) AND (sub_type = ANY ('&#123;10306,10304,10305&#125;'::integer[])))</span><br><span class="line">         Rows Removed by Filter: 13631428</span><br><span class="line"> Planning time: 0.375 ms</span><br><span class="line"> Execution time: 15947.730 ms</span><br><span class="line">(6 rows)</span><br></pre></td></tr></table></figure>

<p>很显然，根据order by create_time desc 作为依据, 来使用test_tbl_create_time_idx (单个字段 create_time 的index)进行扫描，一定会慢，因为满足条件的数据都分布在<strong>前</strong>28w条记录中</p>
<h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><h3 id="改SQL"><a href="#改SQL" class="headerlink" title="改SQL"></a>改SQL</h3><p>a 强制不走cretate_time扫描</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># order by create_time, data_id</span></span><br><span class="line">test=<span class="comment"># explain analyze select data_id from test_tbl where status=0 and city_id=310188 and type=103 and sub_type in(10306,10304,10305) order by create_time desc,1 limit 1;</span></span><br><span class="line">                                                                                      QUERY PLAN                                                                                     </span><br><span class="line"><span class="comment">--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> Limit  (cost=4475.93..4475.93 rows=1 width=16) (actual time=0.193..0.193 rows=1 loops=1)</span><br><span class="line">   -&gt;  Sort  (cost=4475.93..4478.94 rows=1207 width=16) (actual time=0.193..0.193 rows=1 loops=1)</span><br><span class="line">         Sort Key: create_time, data_id</span><br><span class="line">         Sort Method: top-N heapsort  Memory: 25kB</span><br><span class="line">         -&gt;  Index Scan using test_tbl_city_id_sub_type_type_status_idx on test_tbl  (cost=0.44..4469.89 rows=1207 width=16) (actual time=0.128..0.173 rows=15 loops=1)</span><br><span class="line">               Index Cond: ((city_id = 310188) AND (sub_type = ANY ('&#123;10306,10304,10305&#125;'::integer[])) AND (type = 103) AND (status = 0))</span><br><span class="line"> Planning time: 1.614 ms</span><br><span class="line"> Execution time: 0.219 ms</span><br><span class="line">(8 rows)</span><br></pre></td></tr></table></figure>

<p>b 使用with</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">test=<span class="comment"># explain analyze with cte as (select data_id from test_tbl where status=0 and city_id=310188 and type=103  and sub_type in(10306,10304,10305)  order by create_time desc)</span></span><br><span class="line"><span class="keyword">select</span> data_id <span class="keyword">from</span> cte <span class="keyword">limit</span> <span class="number">1</span>;</span><br><span class="line">                                                                                   QUERY PLAN                                                                                   </span><br><span class="line"><span class="comment">---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> Limit  (cost=4535.80..4535.82 rows=1 width=8) (actual time=0.075..0.075 rows=1 loops=1)</span><br><span class="line">   CTE cte</span><br><span class="line">     -&gt;  Sort  (cost=4532.87..4535.80 rows=1169 width=16) (actual time=0.073..0.073 rows=1 loops=1)</span><br><span class="line">           Sort Key: test_tbl.create_time</span><br><span class="line">           Sort Method: quicksort  Memory: 25kB</span><br><span class="line">           -&gt;  Index Scan using idx_test_tbl_city_id_sub_type_type on test_tbl  (cost=0.44..4473.31 rows=1169 width=16) (actual time=0.019..0.067 rows=15 loops=1)</span><br><span class="line">                 Index Cond: ((city_id = 310188) AND (sub_type = ANY ('&#123;10306,10304,10305&#125;'::integer[])) AND (type = 103))</span><br><span class="line">                 Filter: (status = 0)</span><br><span class="line">                 Rows Removed by Filter: 22</span><br><span class="line">   -&gt;  CTE Scan on cte  (cost=0.00..23.38 rows=1169 width=8) (actual time=0.075..0.075 rows=1 loops=1)</span><br><span class="line"> Planning time: 0.306 ms</span><br><span class="line"> Execution time: 0.097 ms</span><br><span class="line">(12 rows)</span><br></pre></td></tr></table></figure>

<h3 id="加多列复合索引"><a href="#加多列复合索引" class="headerlink" title="加多列复合索引"></a>加多列复合索引</h3><p>加到哪几个字段是关键</p>
<p>比如 create index CONCURRENTLY ON test_tbl (city_id,sub_type,create_time desc) where type=103 and status = 0; 就没有效果.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">test=<span class="comment"># select count(distinct city_id), count(distinct sub_type), count(distinct type), count(distinct status) from test_tbl;</span></span><br><span class="line"> count | count | count | count</span><br><span class="line"><span class="comment">-------+-------+-------+-------</span></span><br><span class="line"> 29689 |    42 |     4 |     9</span><br><span class="line">(1 row)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> CONCURRENTLY  <span class="keyword">on</span> test_tbl(city_id, create_time) <span class="keyword">where</span>  <span class="keyword">status</span>=<span class="number">0</span>  <span class="keyword">and</span> <span class="keyword">type</span>=<span class="number">103</span>;</span><br><span class="line"> </span><br><span class="line">test=<span class="comment"># \d test_tbl_city_id_create_time_idx</span></span><br><span class="line"> Index "public.test_tbl_city_id_create_time_idx"</span><br><span class="line">   Column    |            Type             | Definition </span><br><span class="line"><span class="comment">-------------+-----------------------------+-------------</span></span><br><span class="line"> city_id     | integer                     | city_id</span><br><span class="line"> create_time | timestamp without time zone | create_time</span><br><span class="line">btree, for table "public.test_tbl", predicate (status = 0 AND type = 103)</span><br><span class="line"> </span><br><span class="line">test=<span class="comment"># explain analyze select data_id from test_tbl where status=0 and city_id=310188 and type=103 and sub_type in(10306,10304,10305) order by create_time desc limit 10;</span></span><br><span class="line">                                                                                    QUERY PLAN                                                                                   </span><br><span class="line"><span class="comment">----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> Limit  (cost=0.44..764.64 rows=10 width=16) (actual time=6.121..25.471 rows=10 loops=1)</span><br><span class="line">   -&gt;  Index Scan Backward using test_tbl_city_id_create_time_idx on test_tbl  (cost=0.44..91628.47 rows=1199 width=16) (actual time=6.120..25.466 rows=10 loops=1)</span><br><span class="line">         Index Cond: (city_id = 310188)</span><br><span class="line">         Filter: (sub_type = ANY ('&#123;10306,10304,10305&#125;'::integer[]))</span><br><span class="line">         Rows Removed by Filter: 4237</span><br><span class="line"> Planning time: 0.525 ms</span><br><span class="line"> Execution time: 25.512 ms</span><br><span class="line">(7 rows)</span><br><span class="line"> </span><br><span class="line">test=<span class="comment"># explain analyze select data_id from test_tbl where status=0 and city_id=310188 and type=103 and sub_type in(10306,10304,10305) order by create_time desc limit 1;</span></span><br><span class="line">                                                                                   QUERY PLAN                                                                                  </span><br><span class="line"><span class="comment">--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> Limit  (cost=0.44..76.86 rows=1 width=16) (actual time=0.935..0.935 rows=1 loops=1)</span><br><span class="line">   -&gt;  Index Scan Backward using test_tbl_city_id_create_time_idx on test_tbl  (cost=0.44..91628.47 rows=1199 width=16) (actual time=0.934..0.934 rows=1 loops=1)</span><br><span class="line">         Index Cond: (city_id = 310188)</span><br><span class="line">         Filter: (sub_type = ANY ('&#123;10306,10304,10305&#125;'::integer[]))</span><br><span class="line">         Rows Removed by Filter: 796</span><br><span class="line"> Planning time: 0.447 ms</span><br><span class="line"> Execution time: 0.956 ms</span><br><span class="line">(7 rows)</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>带IN条件的联合索引失效</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">test=<span class="comment"># select city_id from test_tbl limit 5;</span></span><br><span class="line"> city_id </span><br><span class="line"><span class="comment">---------</span></span><br><span class="line">  299782</span><br><span class="line">  300002</span><br><span class="line">  298051</span><br><span class="line">  298051</span><br><span class="line">  298051</span><br><span class="line">(5 rows)</span><br><span class="line"></span><br><span class="line">test=<span class="comment"># explain analyze select data_id from test_tbl where status=0 and city_id in (310188, 299782) and type=103 and sub_type in(10306,10304,10305) order by create_time desc limit 1;</span></span><br><span class="line">                                                                                QUERY PLAN                                                                                 </span><br><span class="line"><span class="comment">---------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> Limit  (cost=0.44..116.29 rows=1 width=16) (actual time=0.082..0.082 rows=1 loops=1)</span><br><span class="line">   -&gt;  Index Scan Backward using test_tbl_create_time_idx on test_tbl  (cost=0.44..1937727.22 rows=16726 width=16) (actual time=0.082..0.082 rows=1 loops=1)</span><br><span class="line">         Filter: ((city_id = ANY ('&#123;310188,299782&#125;'::integer[])) AND (status = 0) AND (type = 103) AND (sub_type = ANY ('&#123;10306,10304,10305&#125;'::integer[])))</span><br><span class="line">         Rows Removed by Filter: 37</span><br><span class="line"> Planning time: 0.542 ms</span><br><span class="line"> Execution time: 0.111 ms</span><br><span class="line">(6 rows)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 带IN条件的联合索引失效</span></span><br><span class="line">test=<span class="comment"># select min(city_id), max(city_id) from test_tbl;</span></span><br><span class="line"> min |   max   </span><br><span class="line"><span class="comment">-----+---------</span></span><br><span class="line">   0 | 1800000</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">test=<span class="comment"># explain analyze select data_id from test_tbl where status=0 and city_id in (310188,1800001) and type=103 and sub_type in(10306,10304,10305) order by create_time desc limit 1;</span></span><br><span class="line">                                                                                    QUERY PLAN                                                                                    </span><br><span class="line"><span class="comment">----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> Limit  (cost=0.44..1652.38 rows=1 width=16) (actual time=13331.682..13331.683 rows=1 loops=1)</span><br><span class="line">   -&gt;  Index Scan Backward using test_tbl_create_time_idx on test_tbl  (cost=0.44..1937727.22 rows=1173 width=16) (actual time=13331.681..13331.681 rows=1 loops=1)</span><br><span class="line">         Filter: ((city_id = ANY ('&#123;310188,1800001&#125;'::integer[])) AND (status = 0) AND (type = 103) AND (sub_type = ANY ('&#123;10306,10304,10305&#125;'::integer[])))</span><br><span class="line">         Rows Removed by Filter: 10007847</span><br><span class="line"> Planning time: 0.375 ms</span><br><span class="line"> Execution time: 13331.702 ms</span><br><span class="line">(6 rows)</span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://yq.aliyun.com/articles/647456" target="_blank" rel="noopener">https://yq.aliyun.com/articles/647456</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.yonj1e.top/2019/03/20/dockerfile-usage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="Yang Jie">
      <meta itemprop="description" content="Stay hungry, Stay young">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yonj1e's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/20/dockerfile-usage/" class="post-title-link" itemprop="url">用Dockerfile打造自动化构建工具</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-20 00:00:00" itemprop="dateCreated datePublished" datetime="2019-03-20T00:00:00+00:00">2019-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-18 14:11:26" itemprop="dateModified" datetime="2020-07-18T14:11:26+00:00">2020-07-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index">
                    <span itemprop="name">Docker</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>自动化构建是产品发布过程中必不可少的环节，通常会涉及编译、打包等环节，而这些环节在构建产品时通常会有以下问题：</p>
<ul>
<li>需要直接或间接的写一坨用于构建的shell命令等，不易管理、兼容性较差</li>
<li>重度依赖如编译机或打包机上的软件环境</li>
</ul>
<p>理想情况是：不同的应用都可以在某台负责构建的宿主机上并行无干扰的执行构建操作，且构建中依赖的软件环境、构建流程等都可以由开发人员控制。</p>
<p>到目前为止，能很好的完成以上使命的，可能非docker莫属了！</p>
<p>在docker的世界里，构建交付的是镜像，而能够产生镜像的是Dockerfile。</p>
<ul>
<li>Dockerfile 是专门用来进行自动化构建镜像的编排文件，我们可以通过 docker build命令来自动化地从 Dockerfile所描述的步骤来构建自定义的Docker镜像，这比我们去命令行一条条指令执行的方式构建高效得多。</li>
<li>另一方面，由于 Dockerfile提供了统一的配置语法，因此通过这样一份配置文件，我们可以在各种不同的平台上进行分发，需要时通过 Dockerfile 构建一下就能得到所需的镜像。</li>
<li>Dockerfile 通过与镜像配合使用，使得 Docker镜像构建之时可以充分利用“镜像的缓存功能”，因此也提效不少！</li>
</ul>
<p>写 Dockerfile 也像写代码一样，一份精心设计、Clean Code 的 Dockerfile 能在提高可读性的同时也大大提升 Docker 的使用效率</p>
<h2 id="Dockerfile-命令"><a href="#Dockerfile-命令" class="headerlink" title="Dockerfile 命令"></a>Dockerfile 命令</h2><p>Dockerfile有十几条命令可用于构建镜像，下文将简略介绍这些命令。</p>
<p><strong>ADD</strong></p>
<p>ADD命令有两个参数，源和目标。它的基本作用是从源系统的文件系统上复制文件到目标容器的文件系统。如果源是一个URL，那该URL的内容将被下载并复制到容器中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage: ADD [source directory or URL] [destination directory]</span><br><span class="line">ADD /my_app_folder /my_app_folder</span><br></pre></td></tr></table></figure>

<p><strong>CMD</strong></p>
<p>和RUN命令相似，CMD可以用于执行特定的命令。和RUN不同的是，这些命令不是在镜像构建的过程中执行的，而是在用镜像构建容器后被调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Usage 1: CMD application &quot;argument&quot;, &quot;argument&quot;, ..</span><br><span class="line">CMD &quot;echo&quot; &quot;Hello docker!&quot;</span><br></pre></td></tr></table></figure>

<p><strong>ENTRYPOINT</strong></p>
<p>配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖。</p>
<p>每个 Dockerfile 中只能有一个 ENTRYPOINT，当指定多个时，只有最后一个起效。</p>
<p>ENTRYPOINT 帮助你配置一个容器使之可执行化，如果你结合CMD命令和ENTRYPOINT命令，你可以从CMD命令中移除“application”而仅仅保留参数，参数将传递给ENTRYPOINT命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Usage: ENTRYPOINT application &quot;argument&quot;, &quot;argument&quot;, ..</span><br><span class="line"># Remember: arguments are optional. They can be provided by CMD</span><br><span class="line"># or during the creation of a container.</span><br><span class="line">ENTRYPOINT echo</span><br><span class="line"># Usage example with CMD:</span><br><span class="line"># Arguments set with CMD can be overridden during *run*</span><br><span class="line">CMD &quot;Hello docker!&quot;</span><br><span class="line">ENTRYPOINT echo</span><br></pre></td></tr></table></figure>

<p>*<em>ENV *</em><br>ENV命令用于设置环境变量。这些变量以”key=value”的形式存在，并可以在容器内被脚本或者程序调用。这个机制给在容器中运行应用带来了极大的便利。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Usage: ENV key value</span><br><span class="line">ENV SERVER_WORKS 4</span><br></pre></td></tr></table></figure>

<p><strong>EXPOSE</strong></p>
<p>EXPOSE用来指定端口，使容器内的应用可以通过端口和外界交互。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Usage: EXPOSE [port]</span><br><span class="line">EXPOSE 8080</span><br></pre></td></tr></table></figure>

<p><strong>FROM</strong></p>
<p>FROM命令可能是最重要的Dockerfile命令。改命令定义了使用哪个基础镜像启动构建流程。基础镜像可以为任意镜 像。如果基础镜像没有被发现，Docker将试图从Docker image index来查找该镜像。FROM命令必须是Dockerfile的首个命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Usage: FROM [image name]</span><br><span class="line">FROM ubuntu</span><br></pre></td></tr></table></figure>

<p><strong>MAINTAINER</strong></p>
<p>我建议这个命令放在Dockerfile的起始部分，虽然理论上它可以放置于Dockerfile的任意位置。这个命令用于声明作者，并应该放在FROM的后面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Usage: MAINTAINER [name]</span><br><span class="line">MAINTAINER authors_name</span><br></pre></td></tr></table></figure>

<p><strong>RUN</strong></p>
<p>RUN命令是Dockerfile执行命令的核心部分。它接受命令作为参数并用于创建镜像。不像CMD命令，RUN命令用于创建镜像（在之前commit的层之上形成新的层）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Usage: RUN [command]</span><br><span class="line">RUN aptitude install -y riak</span><br></pre></td></tr></table></figure>

<p><strong>USER</strong></p>
<p>USER命令用于设置运行容器的UID。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Usage: USER [UID]</span><br><span class="line">USER 751</span><br></pre></td></tr></table></figure>

<p><strong>VOLUME</strong></p>
<p>VOLUME命令用于让你的容器访问宿主机上的目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Usage: VOLUME [&quot;/dir_1&quot;, &quot;/dir_2&quot; ..]</span><br><span class="line">VOLUME [&quot;/my_files&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>WORKDIR</strong></p>
<p>WORKDIR命令用于设置CMD指明的命令的运行目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Usage: WORKDIR /path</span><br><span class="line">WORKDIR ~/</span><br></pre></td></tr></table></figure>
<h2 id="使用Dockerfile"><a href="#使用Dockerfile" class="headerlink" title="使用Dockerfile"></a>使用Dockerfile</h2><p>使用Dockerfiles和手工使用Docker Daemon运行命令一样简单。脚本运行后输出为新的镜像ID。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Build an image using the Dockerfile at current location</span><br><span class="line"># Example: sudo docker build -t [name] .</span><br><span class="line">docker build -t pgsql .</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>以下演示以构建centos76+postgresql11镜像为例。</p>
<p>这只是一个简单的示例，将pg源码拷贝到基础镜像然后编译。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">$ cat Dockerfile </span><br><span class="line"><span class="comment"># --------------------------------------------------</span></span><br><span class="line"><span class="comment"># Dockerfile to build postgreSQL container images</span></span><br><span class="line"><span class="comment"># Base on CentOS 7.6</span></span><br><span class="line"><span class="comment"># --------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the base image to neokylin</span></span><br><span class="line"><span class="keyword">FROM</span> docker.io/centos:<span class="number">7.6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># File Author / Maintainer</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> maintainer <span class="string">"yangjie@highgo.com"</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> /bin/<span class="built_in">echo</span> <span class="string">'root:123456'</span> | chpasswd</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> useradd postgres</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> /bin/<span class="built_in">echo</span> <span class="string">'postgres:123456'</span> | chpasswd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Copy postgresql files from the current directory</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> postgres /opt/postgres</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Install necessary tools</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum -y install bison flex readline-devel zlib-devel</span></span><br><span class="line">    &amp;&amp; yum clean all </span><br><span class="line">    &amp;&amp; rm -rf /var/cache/yum</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> /opt/postgres \</span></span><br><span class="line"><span class="bash">    &amp;&amp; ./configure \</span></span><br><span class="line"><span class="bash">    &amp;&amp; make clean; make; make install; \</span></span><br><span class="line"><span class="bash">    &amp;&amp; <span class="built_in">cd</span> contrib/ \</span></span><br><span class="line"><span class="bash">    &amp;&amp; make clean; make; make install;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Setting environment variables</span></span><br><span class="line"><span class="comment"># Install database</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Expose the default port</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">5432</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">22</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the default command to execute</span></span><br><span class="line"><span class="comment"># when creating a new container</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"/usr/sbin/sshd"</span>]</span></span><br></pre></td></tr></table></figure>

<p>构建</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建</span></span><br><span class="line">$ docker build -t pgsql .</span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">$ docker images</span><br><span class="line">REPOSITORY                                TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">pgsql                                     latest              c79f4b0a8f78        5 minutes ago       1.38 GB</span><br><span class="line"><span class="comment"># 启动容器</span></span><br><span class="line">$ docker run -itd --name pgsql pgsql:latest /bin/bash</span><br><span class="line"><span class="comment"># 查看容器</span></span><br><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE                  COMMAND                  CREATED             STATUS              PORTS                      NAMES</span><br><span class="line">365b22da366c        pgsql:latest           <span class="string">"/bin/bash"</span>              5 minutes ago       Up 5 minutes        22/tcp, 80/tcp, 5432/tcp   pgsql</span><br><span class="line"><span class="comment"># 连接容器</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -it pgsql /bin/bash</span><br><span class="line">[root@365b22da366c /]<span class="comment"># chown -R postgres:postgres /usr/local/pgsql/</span></span><br><span class="line">[root@365b22da366c /]<span class="comment"># su - postgres</span></span><br><span class="line">[postgres@365b22da366c ~]$ <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/pgsql/bin/</span><br><span class="line">[postgres@365b22da366c bin]$ ./initdb -D ../data</span><br><span class="line">[postgres@365b22da366c bin]$ ./pg_ctl -D ../data/ start</span><br><span class="line">[postgres@365b22da366c bin]$ ./psql </span><br><span class="line">psql (11.2)</span><br><span class="line">Type <span class="string">"help"</span> <span class="keyword">for</span> <span class="built_in">help</span>.</span><br><span class="line"></span><br><span class="line">postgres=<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<h2 id="镜像大小"><a href="#镜像大小" class="headerlink" title="镜像大小"></a>镜像大小</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">REPOSITORY                                TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">pgsql                                     latest              c79f4b0a8f78        10 minutes ago      1.38 GB</span><br><span class="line">docker.io/centos                          latest              9f38484d220f        10 days ago         202 MB</span><br></pre></td></tr></table></figure>
<p>注意到centos的镜像其实只有202MB，仅仅编译pg竟然到了1.38GB，这就需要进一步了解dockerfile做了什么？</p>
<p>Dockerfile由多条指令构成，随着深入研究Dockerfile与镜像的关系，非常快大家就会发现。</p>
<p>Dockerfile中的每一条指令都会相应于Docker镜像中的一层。</p>
<p>继续以例如以下Dockerfile为例：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">14.04</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> run.sh /</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> /data</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"./run.sh"</span>]</span></span><br></pre></td></tr></table></figure>

<p>通过docker build以上Dockerfile的时候。会在Ubuntu:14.04镜像基础上，加入三层独立的镜像，依次相应于三条不同的命令。</p>
<p>镜像示意图例如以下：</p>
<p><img src="/2019/03/20/dockerfile-usage/1571571250882.png" alt="1571571250882"></p>
<p>有了Dockerfile与镜像关系的初步认识之后，我们再进一步联系到每一层镜像的大小。</p>
<p>不得不说，在层级化管理的Docker镜像中。有不少层大小都为0。</p>
<p>那些镜像层大小不为0的情况，归根结底的原因是：构建Docker镜像时，对当前的文件系统造成了改动更新。</p>
<p>而改动更新的情况主要有两种：</p>
<ol>
<li><p>ADD或COPY命令：ADD或者COPY的作用是在docker build构建镜像时向容器中加入内容。仅仅要内容加入成功，当前构建的那层镜像就是加入内容的大小，如以上命令<code>ADD run.sh /</code>。新构建的那层镜像大小为文件run.sh的大小。</p>
</li>
<li><p>RUN命令：RUN命令的作用是在当前空的镜像层内执行一条命令，倘若执行的命令须要更新磁盘文件。那么全部的更新内容都在存储在当前镜像层中。</p>
</li>
</ol>
<p>举例说明：<code>RUN echo DaoCloud</code>命令不涉及文件系统内容的改动，故命令执行完之后当前镜像层的大小为0；<code>RUN wget http://abc.com/def.tar</code>命令会将压缩包下载至当前文件夹下，因此当前这一层镜像的大小为:对文件系统内容的增量改动部分，即def.tar文件的大小。</p>
<p>再来看一下我们的镜像，我们可以清楚的发现拷贝pg源码占了948MB</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">history</span> c79f4b0a8f78</span><br><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line">c79f4b0a8f78        11 minutes ago      /bin/sh -c <span class="comment">#(nop)  CMD ["/usr/sbin/sshd"]       0 B                 </span></span><br><span class="line">1d374bf6fe39        11 minutes ago      /bin/sh -c <span class="comment">#(nop)  EXPOSE 80/tcp                0 B                 </span></span><br><span class="line">225293fa2cd3        11 minutes ago      /bin/sh -c <span class="comment">#(nop)  EXPOSE 22/tcp                0 B                 </span></span><br><span class="line">b68e1cbfa05f        11 minutes ago      /bin/sh -c <span class="comment">#(nop)  EXPOSE 5432/tcp              0 B                 </span></span><br><span class="line">9b5975854593        11 minutes ago      /bin/sh -c <span class="built_in">set</span> -eux  &amp;&amp; <span class="built_in">cd</span> /opt/postgres  ...   75.5 MB             </span><br><span class="line">af193290b45c        15 minutes ago      /bin/sh -c <span class="built_in">set</span> -x  &amp;&amp; yum -y install bison...   156 MB              </span><br><span class="line">41150c6c7581        16 minutes ago      /bin/sh -c <span class="comment">#(nop) ADD dir:d57fa47decdfdc50...   948 MB              </span></span><br><span class="line">efa2cda50b68        57 minutes ago      /bin/sh -c /bin/<span class="built_in">echo</span> <span class="string">'postgres:123456'</span> | c...   1.83 kB             </span><br><span class="line">a394918a64fd        57 minutes ago      /bin/sh -c useradd postgres                     296 kB              </span><br><span class="line">60abcd73fa1e        57 minutes ago      /bin/sh -c /bin/<span class="built_in">echo</span> <span class="string">'root:123456'</span> | chpasswd   1.52 kB             </span><br><span class="line">3c440ae01e3b        57 minutes ago      /bin/sh -c <span class="comment">#(nop)  LABEL maintainer=yangji...   0 B                 </span></span><br><span class="line">9f38484d220f        10 days ago         /bin/sh -c <span class="comment">#(nop)  CMD ["/bin/bash"]            0 B                 </span></span><br><span class="line">&lt;missing&gt;           10 days ago         /bin/sh -c <span class="comment">#(nop)  LABEL org.label-schema....   0 B                 </span></span><br><span class="line">&lt;missing&gt;           10 days ago         /bin/sh -c <span class="comment">#(nop) ADD file:074f2c974463ab3...   202 MB</span></span><br></pre></td></tr></table></figure>
<p>这里完全可以优化一下：</p>
<p>将下载源码，编译，删除源码放在一条命令中完成。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dockerfile</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">set</span> -eux \</span></span><br><span class="line"><span class="bash">        &amp;&amp; wget https://ftp.postgresql.org/pub/<span class="built_in">source</span>/v11.2/postgresql-11.2.tar.gz \</span></span><br><span class="line"><span class="bash">        &amp;&amp; tar zxvf postgresql-11.2.tar.gz -C /opt &amp;&amp; rm postgresql-11.2.tar.gz \</span></span><br><span class="line"><span class="bash">        &amp;&amp; <span class="built_in">cd</span> /opt/postgresql-11.2 \</span></span><br><span class="line"><span class="bash">        &amp;&amp; ./configure \</span></span><br><span class="line"><span class="bash">        &amp;&amp; make clean; make; make install \</span></span><br><span class="line"><span class="bash">        &amp;&amp; <span class="built_in">cd</span> contrib \</span></span><br><span class="line"><span class="bash">        &amp;&amp; make clean; make; make install \</span></span><br><span class="line"><span class="bash">        &amp;&amp; rm -rf /opt/postgresql-11.2</span></span><br><span class="line"></span><br><span class="line">$ docker build pgsql-<span class="number">11.2</span> .</span><br><span class="line"></span><br><span class="line">$ docker images</span><br><span class="line">REPOSITORY                                TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">pgsql-<span class="number">11.2</span>                                latest              <span class="number">338</span>afc2a0a3e        <span class="number">2</span> minutes ago       <span class="number">383</span> MB</span><br><span class="line"></span><br><span class="line">$ docker history <span class="number">338</span>afc2a0a3e</span><br><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line"><span class="number">338</span>afc2a0a3e        <span class="number">3</span> minutes ago       /bin/sh -c <span class="comment">#(nop)  CMD ["/usr/sbin/sshd"]       0 B                 </span></span><br><span class="line"><span class="number">373751418</span>cf4        <span class="number">3</span> minutes ago       /bin/sh -c <span class="comment">#(nop)  EXPOSE 80/tcp                0 B                 </span></span><br><span class="line"><span class="number">6</span>e555eb07f75        <span class="number">3</span> minutes ago       /bin/sh -c <span class="comment">#(nop)  EXPOSE 22/tcp                0 B                 </span></span><br><span class="line">ae4866a01334        <span class="number">3</span> minutes ago       /bin/sh -c <span class="comment">#(nop)  EXPOSE 5432/tcp              0 B                 </span></span><br><span class="line"><span class="number">5</span>f475c6acf58        <span class="number">3</span> minutes ago       /bin/sh -c set -eux  &amp;&amp; wget https://ftp.p...   <span class="number">24.2</span> MB             </span><br><span class="line">ec3c374d38db        <span class="number">10</span> minutes ago      /bin/sh -c set -x  &amp;&amp; yum -y install bison...   <span class="number">157</span> MB              </span><br><span class="line">efa2cda50b68        About an hour ago   /bin/sh -c /bin/echo <span class="string">'postgres:123456'</span> | c...   <span class="number">1.83</span> kB             </span><br><span class="line">a394918a64fd        About an hour ago   /bin/sh -c useradd postgres                     <span class="number">296</span> kB              </span><br><span class="line"><span class="number">60</span>abcd73fa1e        About an hour ago   /bin/sh -c /bin/echo <span class="string">'root:123456'</span> | chpasswd   <span class="number">1.52</span> kB             </span><br><span class="line"><span class="number">3</span>c440ae01e3b        About an hour ago   /bin/sh -c <span class="comment">#(nop)  LABEL maintainer=yangji...   0 B                 </span></span><br><span class="line"><span class="number">9</span>f38484d220f        <span class="number">10</span> days ago         /bin/sh -c <span class="comment">#(nop)  CMD ["/bin/bash"]            0 B                 </span></span><br><span class="line">&lt;missing&gt;           <span class="number">10</span> days ago         /bin/sh -c <span class="comment">#(nop)  LABEL org.label-schema....   0 B                 </span></span><br><span class="line">&lt;missing&gt;           <span class="number">10</span> days ago         /bin/sh -c <span class="comment">#(nop) ADD file:074f2c974463ab3...   202 MB</span></span><br></pre></td></tr></table></figure>
<p>镜像大小现在只有383MB。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/boshen-hzb/p/6400272.html" target="_blank" rel="noopener">https://www.cnblogs.com/boshen-hzb/p/6400272.html</a></p>
<p><a href="https://www.cnblogs.com/claireyuancy/p/7029126.html" target="_blank" rel="noopener">https://www.cnblogs.com/claireyuancy/p/7029126.html</a></p>
<p><a href="https://blog.csdn.net/a1010256340/article/details/80092038" target="_blank" rel="noopener">https://blog.csdn.net/a1010256340/article/details/80092038</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.yonj1e.top/2019/01/20/understanding-database-sharding/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="Yang Jie">
      <meta itemprop="description" content="Stay hungry, Stay young">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yonj1e's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/20/understanding-database-sharding/" class="post-title-link" itemprop="url">了解数据库分片</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-20 00:00:00" itemprop="dateCreated datePublished" datetime="2019-01-20T00:00:00+00:00">2019-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-18 14:11:26" itemprop="dateModified" datetime="2020-07-18T14:11:26+00:00">2020-07-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Database/" itemprop="url" rel="index">
                    <span itemprop="name">Database</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://www.digitalocean.com/community/tutorials/understanding-database-sharding" target="_blank" rel="noopener">https://www.digitalocean.com/community/tutorials/understanding-database-sharding</a></p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Any application or website that sees significant growth will eventually need to scale in order to accommodate increases in traffic. For data-driven applications and websites, it’s critical that scaling is done in a way that ensures the security and integrity of their data. It can be difficult to predict how popular a website or application will become or how long it will maintain that popularity, which is why some organizations choose a database architecture that allows them to scale their databases dynamically.</p>
<p>任何看到显着增长的应用程序或网站最终都需要扩展以适应流量的增加。对于数据驱动的应用程序和网站，以确保其数据安全性和完整性的方式进行扩展至关重要。可能很难预测网站或应用程序的流行程度或维持流行程度的时间长短，这就是为什么有些组织选择允许它们动态扩展数据库的数据库体系结构的原因。</p>
<p>In this conceptual article, we will discuss one such database architecture: <em>sharded databases</em>. Sharding has been receiving lots of attention in recent years, but many don’t have a clear understanding of what it is or the scenarios in which it might make sense to shard a database. We will go over what sharding is, some of its main benefits and drawbacks, and also a few common sharding methods.</p>
<p>在这篇概念性文章中，我们将讨论一种这样的数据库架构：分片数据库。近年来，Sharding一直受到很多关注，但许多人并没有清楚地了解它是什么，也不清楚在哪些场景下对数据库进行分片是有意义。我们将讨论分片是什么，它的一些主要优点和缺点，以及一些常见的分片方法。</p>
<h2 id="What-is-Sharding"><a href="#What-is-Sharding" class="headerlink" title="What is Sharding?"></a>What is Sharding?</h2><p>Sharding is a database architecture pattern related to <em>horizontal partitioning</em> — the practice of separating one table’s rows into multiple different tables, known as partitions. Each partition has the same schema and columns, but also entirely different rows. Likewise, the data held in each is unique and independent of the data held in other partitions.</p>
<p>Sharding是一种与水平分区相关的数据库体系结构模式 - 将一个表的行分成多个不同的表（称为分区）的做法。每个分区都具有相同的模式和列，但也有完全不同的行。同样，每个数据中保存的数据都是唯一的，并且与其他分区中保存的数据无关。</p>
<p>It can be helpful to think of horizontal partitioning in terms of how it relates to <em>vertical partitioning</em>. In a vertically-partitioned table, entire columns are separated out and put into new, distinct tables. The data held within one vertical partition is independent from the data in all the others, and each holds both distinct rows and columns. The following diagram illustrates how a table could be partitioned both horizontally and vertically:</p>
<p>考虑水平分区与垂直分区的关系，可能会有所帮助。在垂直分区表中，整个列被分离出来并放入新的不同表中。保持在一个垂直分区内的数据独立于所有其他分区中的数据，并且每个数据都包含不同的行和列。下图说明了如何在水平和垂直方向上对表进行分区：</p>
<p><img src="/2019/01/20/understanding-database-sharding/DB_image_1_cropped.png" alt="Example tables showing horizontal and vertical partitioning"></p>
<p>Sharding involves breaking up one’s data into two or more smaller chunks, called <em>logical shards</em>. The logical shards are then distributed across separate database nodes, referred to as <em>physical shards</em>, which can hold multiple logical shards. Despite this, the data held within all the shards collectively represent an entire logical dataset.</p>
<p>分片涉及将一个数据分成两个或多个较小的块，称为逻辑分片。然后，逻辑分片分布在单独的数据库节点上，称为物理分片，它可以容纳多个逻辑分片。尽管如此，所有分片中保存的数据共同代表整个逻辑数据集。</p>
<p>Database shards exemplify a <a href="https://en.wikipedia.org/wiki/Shared-nothing_architecture" target="_blank" rel="noopener"><em>shared-nothing architecture</em></a>. This means that the shards are autonomous; they don’t share any of the same data or computing resources. In some cases, though, it may make sense to replicate certain tables into each shard to serve as reference tables. For example, let’s say there’s a database for an application that depends on fixed conversion rates for weight measurements. By replicating a table containing the necessary conversion rate data into each shard, it would help to ensure that all of the data required for queries is held in every shard.</p>
<p>数据库分片举例说明了<a href="https://en.wikipedia.org/wiki/Shared-nothing_architecture" target="_blank" rel="noopener">shared-nothing架构</a>。这意味着分片是自治的; 它们不共享任何相同的数据或计算资源。但是，在某些情况下，将某些表复制到每个分片中作为参考表可能是有意义的。例如，假设某个应用程序的数据库依赖于用于重量测量的固定转换率。通过将包含必要转换率数据的表复制到每个分片中，有助于确保查询所需的所有数据都保存在每个分片中。</p>
<p>Oftentimes, sharding is implemented at the application level, meaning that the application includes code that defines which shard to transmit reads and writes to. However, some database management systems have sharding capabilities built in, allowing you to implement sharding directly at the database level.</p>
<p>通常，在应用程序级别实现分片，这意味着应用程序包含定义传输读取和写入的分片的代码。但是，某些数据库管理系统内置了分片功能，允许您直接在数据库级别实现分片。</p>
<p>Given this general overview of sharding, let’s go over some of the positives and negatives associated with this database architecture.</p>
<p>给出了分片的一般概述，让我们来看看与此数据库体系结构相关的一些优点和缺点。</p>
<h2 id="Benefits-of-Sharding"><a href="#Benefits-of-Sharding" class="headerlink" title="Benefits of Sharding"></a>Benefits of Sharding</h2><p>The main appeal of sharding a database is that it can help to facilitate <em>horizontal scaling</em>, also known as <em>scaling out</em>. Horizontal scaling is the practice of adding more machines to an existing stack in order to spread out the load and allow for more traffic and faster processing. This is often contrasted with <em>vertical scaling</em>, otherwise known as <em>scaling up</em>, which involves upgrading the hardware of an existing server, usually by adding more RAM or CPU.</p>
<p>分片数据库的主要吸引力在于它可以帮助促进水平扩展，也称为横向扩展。水平扩展是向现有堆栈添加更多机器的做法，以便分散负载并允许更多流量和更快的处理。这通常与垂直扩展形成对比，也称为纵向扩展，这涉及升级现有服务器的硬件，通常是添加更多RAM或CPU。</p>
<p>It’s relatively simple to have a relational database running on a single machine and scale it up as necessary by upgrading its computing resources. Ultimately, though, any non-distributed database will be limited in terms of storage and compute power, so having the freedom to scale horizontally makes your setup far more flexible.</p>
<p>让关系数据库在单个机器上运行并通过升级其计算资源根据需要进行扩展是相对简单的。但最终，任何非分布式数据库在存储和计算能力方面都会受到限制，因此可以自由地水平扩展，使您的设置更加灵活。</p>
<p>Another reason why some might choose a sharded database architecture is to speed up query response times. When you submit a query on a database that hasn’t been sharded, it may have to search every row in the table you’re querying before it can find the result set you’re looking for. For an application with a large, monolithic database, queries can become prohibitively slow. By sharding one table into multiple, though, queries have to go over fewer rows and their result sets are returned much more quickly.</p>
<p>某些人可能选择分片数据库体系结构的另一个原因是加快查询响应时间。当您对尚未分片的数据库提交查询时，可能必须先搜索您查询的表中的每一行，然后才能找到您要查找的结果集。对于具有大型单片数据库的应用程序，查询可能变得极其缓慢。但是，通过将一个表分成多个，查询只需遍历更少的行，并且返回结果集的速度要快得多。</p>
<p>Sharding can also help to make an application more reliable by mitigating the impact of outages. If your application or website relies on an unsharded database, an outage has the potential to make the entire application unavailable. With a sharded database, though, an outage is likely to affect only a single shard. Even though this might make some parts of the application or website unavailable to some users, the overall impact would still be less than if the entire database crashed.</p>
<p>分片还可以通过减少中断的影响来帮助提高应用程序的可靠性。如果您的应用程序或网站依赖于未加密的数据库，则中断可能会导致整个应用程序不可用。但是，对于分片数据库，中断可能只会影响单个分片。即使这可能使某些用户无法使用某些应用程序或网站部分，但整体影响仍会低于整个数据库崩溃的影响。</p>
<h2 id="Drawbacks-of-Sharding"><a href="#Drawbacks-of-Sharding" class="headerlink" title="Drawbacks of Sharding"></a>Drawbacks of Sharding</h2><p>While sharding a database can make scaling easier and improve performance, it can also impose certain limitations. Here, we’ll discuss some of these and why they might be reasons to avoid sharding altogether.</p>
<p>虽然对数据库进行分片可以使扩展更容易并提高性能，但它也可能会带来某些限制。在这里，我们将讨论其中的一些以及为什么它们可能是完全避免分片的原因。</p>
<p>The first difficulty that people encounter with sharding is the sheer complexity of properly implementing a sharded database architecture. If done incorrectly, there’s a significant risk that the sharding process can lead to lost data or corrupted tables. Even when done correctly, though, sharding is likely to have a major impact on your team’s workflows. Rather than accessing and managing one’s data from a single entry point, users must manage data across multiple shard locations, which could potentially be disruptive to some teams.</p>
<p>人们遇到分片的第一个困难是正确实现分片数据库体系结构的复杂性。如果操作不正确，则分片过程可能会导致数据丢失或表损坏。即使正确完成，分片也可能对您团队的工作流程产生重大影响。用户必须跨多个分片位置管理数据，而不是从单个入口点访问和管理一个数据，这可能会对某些团队造成干扰。</p>
<p>One problem that users sometimes encounter after having sharded a database is that the shards eventually become unbalanced. By way of example, let’s say you have a database with two separate shards, one for customers whose last names begin with letters A through M and another for those whose names begin with the letters N through Z. However, your application serves an inordinate amount of people whose last names start with the letter G. Accordingly, the A-M shard gradually accrues more data than the N-Z one, causing the application to slow down and stall out for a significant portion of your users. The A-M shard has become what is known as a <em>database hotspot</em>. In this case, any benefits of sharding the database are canceled out by the slowdowns and crashes. The database would likely need to be repaired and resharded to allow for a more even data distribution.</p>
<p>用户在对数据库进行分片后有时会遇到的一个问题是分片最终会变得不平衡。举例来说，假设您有一个带有两个单独分片的数据库，一个用于姓氏以字母A到M开头的客户，另一个用于名称以字母N到Z开头的客户。但是，您的应用程序为大量姓氏以字母G开头的人提供服务。因此，A-M分片逐渐累积的数据多于N-Z分片，导致应用程序为您的大部分用户放慢速度并使其处于停滞状态。A-M分片已成为所谓的数据库热点。在这种情况下，分片数据库的任何好处都会被减速和崩溃所抵消。数据库可能需要修复和重新分片才能实现更均匀的数据分发。</p>
<p>Another major drawback is that once a database has been sharded, it can be very difficult to return it to its unsharded architecture. Any backups of the database made before it was sharded won’t include data written since the partitioning. Consequently, rebuilding the original unsharded architecture would require merging the new partitioned data with the old backups or, alternatively, transforming the partitioned DB back into a single DB, both of which would be costly and time consuming endeavors.</p>
<p>另一个主要缺点是，一旦数据库被分片，就很难将其返回到未分片的体系结构中。在对数据库进行分片之前所做的任何备份都不会包括自分片后写入的数据。因此，重建原始的未分片体系结构将需要将新的分区数据与旧的备份合并，或者，将分片的DB转换回单个DB，这两个过程都将花费大量的时间和精力。</p>
<p>A final disadvantage to consider is that sharding isn’t natively supported by every database engine. For instance, PostgreSQL does not include automatic sharding as a feature, although it is possible to manually shard a PostgreSQL database. There are a number of Postgres forks that do include automatic sharding, but these often trail behind the latest PostgreSQL release and lack certain other features. Some specialized database technologies — like MySQL Cluster or certain database-as-a-service products like MongoDB Atlas — do include auto-sharding as a feature, but vanilla versions of these database management systems do not. Because of this, sharding often requires a “roll your own” approach. This means that documentation for sharding or tips for troubleshooting problems are often difficult to find.</p>
<p>要考虑的最后一个缺点是每个数据库引擎本身都不支持分片。例如，PostgreSQL不包括自动分片作为功能，尽管可以手动分片PostgreSQL数据库。有许多Postgres分支包括自动分片，但这些分支通常落后于最新的PostgreSQL版本，缺乏某些其他功能。一些专门的数据库技术 - 如MySQL Cluster或某些数据库即服务产品（如MongoDB Atlas）确实包含自动分片功能，但这些数据库管理系统的普通版本却没有。因此，分片通常需要自己动手的方法。这意味着通常很难找到用于分片的文档或用于解决问题的提示。</p>
<p>These are, of course, only some general issues to consider before sharding. There may be many more potential drawbacks to sharding a database depending on its use case.</p>
<p>当然，这些只是在分片之前要考虑的一些一般性问题。根据其用例，对数据库进行分片可能存在许多潜在的缺点。</p>
<p>Now that we’ve covered a few of sharding’s drawbacks and benefits, we will go over a few different architectures for sharded databases.</p>
<p>现在我们已经介绍了一些分片的缺点和好处，我们将讨论一些分片数据库的不同架构。</p>
<h2 id="Sharding-Architectures"><a href="#Sharding-Architectures" class="headerlink" title="Sharding Architectures"></a>Sharding Architectures</h2><p>Once you’ve decided to shard your database, the next thing you need to figure out is how you’ll go about doing so. When running queries or distributing incoming data to sharded tables or databases, it’s crucial that it goes to the correct shard. Otherwise, it could result in lost data or painfully slow queries. In this section, we’ll go over a few common sharding architectures, each of which uses a slightly different process to distribute data across shards.</p>
<p>一旦你决定对你的数据库进行分片，你需要弄清楚的是你将如何去做。在运行查询或将传入数据分发到分片表或数据库时，它必须转到正确的分片。否则，它可能导致数据丢失或查询速度缓慢。在本节中，我们将介绍一些常见的分片架构，每个架构使用稍微不同的过程来跨分片分发数据。</p>
<h3 id="Key-Based-Sharding"><a href="#Key-Based-Sharding" class="headerlink" title="Key Based Sharding"></a>Key Based Sharding</h3><p><em>Key based sharding</em>, also known as <em>hash based sharding</em>, involves using a value taken from newly written data — such as a customer’s ID number, a client application’s IP address, a ZIP code, etc. — and plugging it into a <em>hash function</em> to determine which shard the data should go to. A hash function is a function that takes as input a piece of data (for example, a customer email) and outputs a discrete value, known as a <em>hash value</em>. In the case of sharding, the hash value is a shard ID used to determine which shard the incoming data will be stored on. Altogether, the process looks like this:</p>
<p>基于键值的分片（也称为基于散列的分片）涉及使用从新写入的数据中获取的值 - 例如客户的ID号，客户端应用程序的IP地址，邮政编码等 - 并将其插入哈希函数以确定数据应该去哪个分片。哈希函数是将一段数据（例如，客户电子邮件）作为输入并输出离散值（称为哈希值）的函数。在分片的情况下，散列值是一个分片ID，用于确定传入数据将存储在哪个分片上。总而言之，这个过程看起来像这样：</p>
<p><img src="/2019/01/20/understanding-database-sharding/DB_image_2_cropped.png" alt="Key based sharding example diagram"></p>
<p>To ensure that entries are placed in the correct shards and in a consistent manner, the values entered into the hash function should all come from the same column. This column is known as a <em>shard key</em>. In simple terms, shard keys are similar to <a href="https://en.wikipedia.org/wiki/Primary_key" target="_blank" rel="noopener"><em>primary keys</em></a> in that both are columns which are used to establish a unique identifier for individual rows. Broadly speaking, a shard key should be static, meaning it shouldn’t contain values that might change over time. Otherwise, it would increase the amount of work that goes into update operations, and could slow down performance.</p>
<p>为了确保条目以正确的方式放置在正确的分片中，输入散列函数的值应该都来自同一列。此列称为分片key。简单来说，分片键与<a href="https://en.wikipedia.org/wiki/Primary_key" target="_blank" rel="noopener">主键</a>类似，因为它们都是用于为各行建立唯一标识符的列。一般来说，分片键应该是静态的，这意味着它不应包含可能随时间变化的值。否则，它会增加更新操作的工作量，并可能降低性能。</p>
<p>While key based sharding is a fairly common sharding architecture, it can make things tricky when trying to dynamically add or remove additional servers to a database. As you add servers, each one will need a corresponding hash value and many of your existing entries, if not all of them, will need to be remapped to their new, correct hash value and then migrated to the appropriate server. As you begin rebalancing the data, neither the new nor the old hashing functions will be valid. Consequently, your server won’t be able to write any new data during the migration and your application could be subject to downtime.</p>
<p>虽然基于键值的分片是一种相当常见的分片架构，但在尝试动态添加或删除数据库中的其他服务器时，它会使事情变得棘手。在添加服务器时，每个服务器都需要一个相应的哈希值，并且许多现有条目（如果不是全部）都需要重新映射到新的正确哈希值，然后迁移到相应的服务器。当您开始重新平衡数据时，新旧散列函数都不会有效。因此，您的服务器将无法在迁移期间写入任何新数据，您的应用程序可能会停机。</p>
<p>The main appeal of this strategy is that it can be used to evenly distribute data so as to prevent hotspots. Also, because it distributes data algorithmically, there’s no need to maintain a map of where all the data is located, as is necessary with other strategies like range or directory based sharding.</p>
<p>该策略的主要吸引力在于它可以用于均匀分布数据以防止热点。此外，由于它以算法方式分配数据，因此无需维护所有数据所在位置的映射，这是其他策略（如范围或基于目录的分片）所必需的。</p>
<h3 id="Range-Based-Sharding"><a href="#Range-Based-Sharding" class="headerlink" title="Range Based Sharding"></a>Range Based Sharding</h3><p><em>Range based sharding</em> involves sharding data based on ranges of a given value. To illustrate, let’s say you have a database that stores information about all the products within a retailer’s catalog. You could create a few different shards and divvy up each products’ information based on which price range they fall into, like this:</p>
<p>基于范围的分片涉及基于给定值的范围分片数据。为了说明，假设您有一个数据库，用于存储零售商目录中所有产品的信息。您可以创建一些不同的分片，并根据每个产品的价格范围分配每个产品的信息，如下所示：</p>
<p><img src="/2019/01/20/understanding-database-sharding/DB_image_3_cropped.png" alt="Range based sharding example diagram"></p>
<p>The main benefit of range based sharding is that it’s relatively simple to implement. Every shard holds a different set of data but they all have an identical schema as one another, as well as the original database. The application code just reads which range the data falls into and writes it to the corresponding shard.</p>
<p>基于范围的分片的主要好处是它实现起来相对简单。每个分片都包含一组不同的数据，但它们都具有相同的模式，以及原始数据库。应用程序代码只读取数据所属的范围并将其写入相应的分片。</p>
<p>On the other hand, range based sharding doesn’t protect data from being unevenly distributed, leading to the aforementioned database hotspots. Looking at the example diagram, even if each shard holds an equal amount of data the odds are that specific products will receive more attention than others. Their respective shards will, in turn, receive a disproportionate number of reads.</p>
<p>另一方面，基于范围的分片不能防止数据分布不均匀，导致上述数据库热点。查看示例图，即使每个分片拥有相同数量的数据，特定产品的可能性也会高于其他产品。反过来，它们各自的分片将接收不成比例的读取次数。</p>
<h3 id="Directory-Based-Sharding"><a href="#Directory-Based-Sharding" class="headerlink" title="Directory Based Sharding"></a>Directory Based Sharding</h3><p>To implement <em>directory based sharding</em>, one must create and maintain a <em>lookup table</em> that uses a shard key to keep track of which shard holds which data. In a nutshell, a lookup table is a table that holds a static set of information about where specific data can be found. The following diagram shows a simplistic example of directory based sharding:</p>
<p>要实现基于目录的分片，必须创建并维护一个查找表，该查找表使用分片键来跟踪哪个分片包含哪些数据。简而言之，查找表是一个表，其中包含有关可以找到特定数据的静态信息集。下图显示了基于目录的分片的简单示例：</p>
<p><img src="/2019/01/20/understanding-database-sharding/DB_image_4_cropped.png" alt="Directory based sharding example diagram"></p>
<p>Here, the <strong>Delivery Zone</strong> column is defined as a shard key. Data from the shard key is written to the lookup table along with whatever shard each respective row should be written to. This is similar to range based sharding, but instead of determining which range the shard key’s data falls into, each key is tied to its own specific shard. Directory based sharding is a good choice over range based sharding in cases where the shard key has a low cardinality and it doesn’t make sense for a shard to store a range of keys. Note that it’s also distinct from key based sharding in that it doesn’t process the shard key through a hash function; it just checks the key against a lookup table to see where the data needs to be written.</p>
<p>此处，”Delivery Zone“列定义为分片键。来自分片键的数据被写入查找表以及应该写入每个相应行的任何分片。这与基于范围的分片类似，但不是确定分片键的数据属于哪个范围，而是将每个键绑定到其自己的特定分片。在分片键具有低基数并且分片存储一系列键没有意义的情况下，基于目录分片是比基于范围分片更理想的选择。请注意，它也不同于基于键值的分片，因为它不通过散列函数处理分片键; 它只是根据查找表检查key，以查看数据需要写入的位置。</p>
<p>The main appeal of directory based sharding is its flexibility. Range based sharding architectures limit you to specifying ranges of values, while key based ones limit you to using a fixed hash function which, as mentioned previously, can be exceedingly difficult to change later on. Directory based sharding, on the other hand, allows you to use whatever system or algorithm you want to assign data entries to shards, and it’s relatively easy dynamically add shards using this approach.</p>
<p>基于目录的分片的主要吸引力在于其灵活性。基于范围的分片架构限制您指定值的范围，而基于键值的分片限制您使用固定的散列函数，如前所述，稍后可能非常难以更改该函数。另一方面，基于目录的分片允许您使用任何你想要的系统或算法将数据条目分配给分片，并且使用此方法动态添加分片相对容易。</p>
<p>While directory based sharding is the most flexible of the sharding methods discussed here, the need to connect to the lookup table before every query or write can have a detrimental impact on an application’s performance. Furthermore, the lookup table can become a single point of failure: if it becomes corrupted or otherwise fails, it can impact one’s ability to write new data or access their existing data.</p>
<p>虽然基于目录的分片是这里讨论的最灵活的分片方法，但是在每次查询或写入之前连接到查找表，会对应用程序的性能产生不利影响。此外，查找表可能成为单点故障：如果它被损坏或以其他方式失败，它可能会影响一个人编写新数据或访问其现有数据的能力。</p>
<h2 id="Should-I-Shard"><a href="#Should-I-Shard" class="headerlink" title="Should I Shard?"></a>Should I Shard?</h2><p>Whether or not one should implement a sharded database architecture is almost always a matter of debate. Some see sharding as an inevitable outcome for databases that reach a certain size, while others see it as a headache that should be avoided unless it’s absolutely necessary, due to the operational complexity that sharding adds.</p>
<p>是否应该实现分片数据库架构几乎总是一个争论的问题。有些人认为分片是达到一定规模的数据库的必然结果，而其他人则认为这是一个令人头疼的问题，除非绝对必要，否则应该避免，因为分片增加了操作的复杂性。</p>
<p>Because of this added complexity, sharding is usually only performed when dealing with very large amounts of data. Here are some common scenarios where it may be beneficial to shard a database:</p>
<p>由于这种增加的复杂性，通常仅在处理非常大量的数据时才执行分片。以下是一些常见方案，其中对数据库进行分片可能是有益的：</p>
<ul>
<li>The amount of application data grows to exceed the storage capacity of a single database node.</li>
<li>应用程序数据量增长到超过单个数据库节点的存储容量。</li>
<li>The volume of writes or reads to the database surpasses what a single node or its read replicas can handle, resulting in slowed response times or timeouts.</li>
<li>对数据库的写入或读取量超过单个节点或其读取副本可以处理的量，从而导致响应时间减慢或超时。</li>
<li>The network bandwidth required by the application outpaces the bandwidth available to a single database node and any read replicas, resulting in slowed response times or timeouts.</li>
<li>应用程序所需的网络带宽超过单个数据库节点和任何只读副本可用的带宽，从而导致响应时间减慢或超时。</li>
</ul>
<p>Before sharding, you should exhaust all other options for optimizing your database. Some optimizations you might want to consider include:</p>
<p>在分片之前，您应该用尽所有其他选项来优化数据库。您可能需要考虑的一些优化包括：</p>
<ul>
<li><strong>Setting up a remote database</strong>. If you’re working with a monolithic application in which all of its components reside on the same server, you can improve your database’s performance by moving it over to its own machine. This doesn’t add as much complexity as sharding since the database’s tables remain intact. However, it still allows you to vertically scale your database apart from the rest of your infrastructure.</li>
<li><strong>设置远程数据库</strong>。如果您正在使用其所有组件都驻留在同一服务器上的单一应用程序，则可以通过将其移动到自己的计算机来提高数据库的性能。由于数据库的表保持不变，因此这不会增加分片的复杂性。但是，它仍允许您将数据库与其他基础结构进行垂直扩展。</li>
<li><strong>Implementing caching</strong>. If your application’s read performance is what’s causing you trouble, caching is one strategy that can help to improve it. Caching involves temporarily storing data that has already been requested in memory, allowing you to access it much more quickly later on.</li>
<li><strong>实现缓存</strong>。如果您的应用程序的读取性能导致您遇到麻烦，那么缓存是一种可以帮助改进它的策略。缓存涉及临时存储已在内存中请求的数据，以便您以后更快地访问它。</li>
<li><strong>Creating one or more read replicas</strong>. Another strategy that can help to improve read performance, this involves copying the data from one database server (the <em>primary server</em>) over to one or more <em>secondary servers</em>. Following this, every new write goes to the primary before being copied over to the secondaries, while reads are made exclusively to the secondary servers. Distributing reads and writes like this keeps any one machine from taking on too much of the load, helping to prevent slowdowns and crashes. Note that creating read replicas involves more computing resources and thus costs more money, which could be a significant constraint for some.</li>
<li><strong>创建一个或多个只读副本</strong>。另一种有助于提高读取性能的策略，包括将数据从一个数据库服务器（主服务器）复制到一个或多个备用服务器。在此之后，每个新写入在复制到备节点之前都会转到主节点，而只能对备用服务器进行读取。像这样分发读写可以防止任何一台机器承担过多的负载，从而有助于防止速度下降和崩溃。请注意，创建只读副本涉及更多的计算资源，因此需要花费更多的钱，这可能是一些人的重要约束。</li>
<li><strong>Upgrading to a larger server</strong>. In most cases, scaling up one’s database server to a machine with more resources requires less effort than sharding. As with creating read replicas, an upgraded server with more resources will likely cost more money. Accordingly, you should only go through with resizing if it truly ends up being your best option.</li>
<li><strong>升级到更大的服务器</strong>。在大多数情况下，将一个人的数据库服务器扩展到具有更多资源的计算机比分片需要更少的工作量。与创建只读副本一样，具有更多资源的升级服务器可能会花费更多的钱。因此，如果它真的最终成为您的最佳选择，您应该只进行调整大小。</li>
</ul>
<p>Bear in mind that if your application or website grows past a certain point, none of these strategies will be enough to improve performance on their own. In such cases, sharding may indeed be the best option for you.</p>
<p>请记住，如果您的应用程序或网站超过某一点，那么这些策略都不足以提高自己的性能。在这种情况下，分片可能确实是您的最佳选择。</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Sharding can be a great solution for those looking to scale their database horizontally. However, it also adds a great deal of complexity and creates more potential failure points for your application. Sharding may be necessary for some, but the time and resources needed to create and maintain a sharded architecture could outweigh the benefits for others.</p>
<p>对于那些希望横向扩展数据库的人来说，分片是一个很好的解决方案。但是，它还会增加很多复杂性，并为您的应用程序创建更多潜在的故障点。某些人可能需要进行分片，但创建和维护分片结构所需的时间和资源可能会超过其他人的好处。</p>
<p>By reading this conceptual article, you should have a clearer understanding of the pros and cons of sharding. Moving forward, you can use this insight to make a more informed decision about whether or not a sharded database architecture is right for your application.</p>
<p>通过阅读这篇概念性文章，您应该更清楚地了解分片的优缺点。展望未来，您可以使用此洞察力来更明智地决定分片数据库体系结构是否适合您的应用程序。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.yonj1e.top/2018/12/29/misoperation-recovery/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="Yang Jie">
      <meta itemprop="description" content="Stay hungry, Stay young">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yonj1e's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/29/misoperation-recovery/" class="post-title-link" itemprop="url">浅谈数据库误操作恢复</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-29 00:00:00" itemprop="dateCreated datePublished" datetime="2018-12-29T00:00:00+00:00">2018-12-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-18 14:11:26" itemprop="dateModified" datetime="2020-07-18T14:11:26+00:00">2020-07-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/" itemprop="url" rel="index">
                    <span itemprop="name">PostgreSQL</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在使用数据库的过程中，不管是业务开发者还是运维人员，都有可能对数据库进行误操作，比如全表不带条件的update或delete等。</p>
<h2 id="恢复措施"><a href="#恢复措施" class="headerlink" title="恢复措施"></a>恢复措施</h2><p>误操作之后又有哪些补救措施呢？</p>
<ul>
<li>延迟从库：发现误操作后，尽快利用从库还原主库。</li>
<li>基于时间点恢复（PITR）：使用由连续归档功能创建的基础备份和归档日志将数据库群恢复到任何时间点的功能。</li>
<li>闪回方案：是成本最低的一种方式，能够有效的、快速地处理一些数据库误操作等。</li>
</ul>
<h2 id="闪回方案"><a href="#闪回方案" class="headerlink" title="闪回方案"></a>闪回方案</h2><p>闪回技术与介质恢复相比，在易用性、可用性和还原时间方面有明显的优势。这个特性大大的减少了采用时点恢复所需的工作量以及数据库脱机的时间。</p>
<p>闪回查询是指针对特定的表来查询特定的时间段内的数据变化情况来确定是否将表闪回到某一个特定的时刻以保证数据无误存在。</p>
<p>实现原理是根据PostgreSQL多版本并发控制机制、元组可见性检查规则实现，多版本保留死亡元祖，保证误操作之前的版本存在，用于闪回查询，其次，修改可见性检查规则，使事务在执行时，查询误操作之前的版本，通过闪回查询历史版本还原数据库在错误发生点之前。</p>
<p>为了降低保留历史版本带来的膨胀等诸多问题，vacuum需要选择性的清理历史数据，以满足闪回及PG本身正常运行的需要。</p>
<p>使用语法上整体保持与Oracle兼容，使用更加方便。元组头不保存事务时间信息，需要开启<code>track_commit_timestamp = on</code>，获取事务提交时间，以支持通过事务号、时间戳进行闪回查询。</p>
<h2 id="基于undo"><a href="#基于undo" class="headerlink" title="基于undo"></a>基于undo</h2><p>PostgreSQL 中很多机制是跟堆表以及这种多版本实现相关的，为了避免这种多版本实现带来的诸多问题，社区开发了基于回滚段的堆表实现，详细可参考zheap。</p>
<p>zheap一种新的存储方式，三个主要目标：</p>
<ol>
<li>对膨胀提供更好的控制</li>
<li>避免重写堆页，可以减少写放大</li>
<li>通过缩小元组头和消除大多数对齐填充来减少元组大小</li>
</ol>
<p>zheap 将通过允许就地更新来防止膨胀，zheap只会保存最后一个版本的数据在数据文件中，tupler header没有了，所有事务信息都存储在 undo 中，因此元组不需要存储此类信息的字段。</p>
<p>每个 undo 记录头包含正在执行操作的事务的先前 undo 记录指针的位置，因此，特定事务中的 undo 记录形成单个链接链，可以遍历undo chain来查找历史版本。</p>
<p>以后，可以基于回滚段实现更强大的闪回功能！</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="延迟从库"><a href="#延迟从库" class="headerlink" title="延迟从库"></a>延迟从库</h3><p>默认情况下，备用服务器会尽快从主服务器恢复WAL记录。</p>
<p>拥有时间延迟的数据副本可能很有用，可以提供纠正数据丢失错误的机会。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 是应用延迟，不是传输延迟</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 主库还是会等从库落盘才会提交</span></span><br><span class="line">recovery_min_apply_delay （integer）</span><br></pre></td></tr></table></figure>

<p>使用repmgr搭建的流复制集群，修改备节点recovery.conf，设置recovery_min_apply_delay = 5min</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> primary</span></span><br><span class="line">[yangjie@young-91 bin]$ ./repmgr cluster show</span><br><span class="line"> ID | Name     | Role    | Status    | Upstream | Location | Replication lag | Last replayed LSN</span><br><span class="line">----+----------+---------+-----------+----------+----------+-----------------+-------------------</span><br><span class="line"> 1  | young-91 | primary | * running |          | default  | n/a             | none             </span><br><span class="line"> 2  | young-90 | standby |   running | young-91 | default  | 0 bytes         | 0/20235CF0</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> standby</span></span><br><span class="line">[yangjie@young-90 bin] ./repmgr cluster show</span><br><span class="line"> ID | Name     | Role    | Status    | Upstream | Location | Replication lag | Last replayed LSN</span><br><span class="line">----+----------+---------+-----------+----------+----------+-----------------+-------------------</span><br><span class="line"> 1  | young-91 | primary | * running |          | default  | n/a             | none             </span><br><span class="line"> 2  | young-90 | standby |   running | young-91 | default  | 0 bytes         | 0/20235CF0  </span><br><span class="line">[yangjie@young-90 bin]$ cat ../data/recovery.conf </span><br><span class="line">standby_mode = 'on'</span><br><span class="line">primary_conninfo = 'host=''young-91'' user=repmgr connect_timeout=2 fallback_application_name=repmgr application_name=''young-90'''</span><br><span class="line">recovery_target_timeline = 'latest'</span><br><span class="line">recovery_min_apply_delay = 5min</span><br></pre></td></tr></table></figure>

<p>在主节点创建表并插入几条数据，检查复制延迟</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- primary</span></span><br><span class="line"><span class="comment">-- 主节点创建表并插入几条测试数据</span></span><br><span class="line">postgres=<span class="comment"># CREATE TABLE test_recovery_delay(id int, ts timestamp);</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span></span><br><span class="line">postgres=<span class="comment"># INSERT INTO test_recovery_delay VALUES (1,now());</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">postgres=<span class="comment"># INSERT INTO test_recovery_delay VALUES (2,now());</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">postgres=<span class="comment"># SELECT * FROM test_recovery_delay ;</span></span><br><span class="line"> <span class="keyword">id</span> |             ts             </span><br><span class="line"><span class="comment">----+----------------------------</span></span><br><span class="line">  <span class="number">1</span> | <span class="number">2019</span><span class="number">-01</span><span class="number">-08</span> <span class="number">13</span>:<span class="number">07</span>:<span class="number">12.699596</span></span><br><span class="line">  <span class="number">2</span> | <span class="number">2019</span><span class="number">-01</span><span class="number">-08</span> <span class="number">13</span>:<span class="number">07</span>:<span class="number">16.291744</span></span><br><span class="line">(<span class="number">2</span> <span class="keyword">rows</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- standby</span></span><br><span class="line">postgres=<span class="comment"># \d</span></span><br><span class="line">                   <span class="keyword">List</span> <span class="keyword">of</span> relations</span><br><span class="line"> <span class="keyword">Schema</span> |           <span class="keyword">Name</span>           |   <span class="keyword">Type</span>   |  Owner  </span><br><span class="line"><span class="comment">--------+--------------------------+----------+---------</span></span><br><span class="line"> <span class="keyword">public</span> | t_test                   | <span class="keyword">TABLE</span>    | yangjie</span><br><span class="line"> <span class="keyword">public</span> | t_test_id_seq            | <span class="keyword">sequence</span> | yangjie</span><br><span class="line"> <span class="keyword">public</span> | <span class="keyword">test</span>                     | <span class="keyword">TABLE</span>    | yangjie</span><br><span class="line">(<span class="number">3</span> <span class="keyword">rows</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 等五分钟</span></span><br><span class="line"></span><br><span class="line">postgres=<span class="comment"># \d</span></span><br><span class="line">                   <span class="keyword">List</span> <span class="keyword">of</span> relations</span><br><span class="line"> <span class="keyword">Schema</span> |           <span class="keyword">Name</span>           |   <span class="keyword">Type</span>   |  Owner  </span><br><span class="line"><span class="comment">--------+--------------------------+----------+---------</span></span><br><span class="line"> <span class="keyword">public</span> | t_test                   | <span class="keyword">TABLE</span>    | yangjie</span><br><span class="line"> <span class="keyword">public</span> | t_test_id_seq            | <span class="keyword">sequence</span> | yangjie</span><br><span class="line"> <span class="keyword">public</span> | <span class="keyword">test</span>                     | <span class="keyword">TABLE</span>    | yangjie</span><br><span class="line"> <span class="keyword">public</span> | test_recovery_delay      | <span class="keyword">TABLE</span>    | yangjie</span><br><span class="line">(<span class="number">4</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>

<p>也可以通过 repmgr node status 查看Last received LSN，Last replayed LSN，Replication lag等信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> standby</span></span><br><span class="line">[yangjie@young-90 bin]$ ./repmgr node status</span><br><span class="line">Node "young-90":</span><br><span class="line">	postgres Database version: 5.1.0</span><br><span class="line">	Total data size: 397 MB</span><br><span class="line">	Conninfo: host=young-90 user=repmgr dbname=repmgr connect_timeout=2</span><br><span class="line">	Role: standby</span><br><span class="line">	WAL archiving: off</span><br><span class="line">	Archive command: (none)</span><br><span class="line">	Replication connections: 0 (of maximal 10)</span><br><span class="line">	Replication slots: 0 (of maximal 10)</span><br><span class="line">	Upstream node: young-91 (ID: 1)</span><br><span class="line">	Replication lag: 395 seconds</span><br><span class="line">	Last received LSN: 0/202A8ED8</span><br><span class="line">	Last replayed LSN: 0/20295440</span><br></pre></td></tr></table></figure>

<p>或者SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ts, </span><br><span class="line">		last_wal_receive_lsn, </span><br><span class="line">		last_wal_replay_lsn, </span><br><span class="line">		last_xact_replay_timestamp, </span><br><span class="line">	<span class="keyword">CASE</span> <span class="keyword">WHEN</span> (last_wal_receive_lsn = last_wal_replay_lsn) </span><br><span class="line">		<span class="keyword">THEN</span> <span class="number">0</span>::<span class="built_in">INT</span> </span><br><span class="line">	<span class="keyword">ELSE</span> </span><br><span class="line">		<span class="keyword">EXTRACT</span>(epoch <span class="keyword">FROM</span> (pg_catalog.clock_timestamp() - last_xact_replay_timestamp))::<span class="built_in">INT</span> </span><br><span class="line">	<span class="keyword">END</span> <span class="keyword">AS</span> replication_lag_time, </span><br><span class="line">	<span class="keyword">COALESCE</span>(last_wal_receive_lsn, <span class="string">'0/0'</span>) &gt;= last_wal_replay_lsn <span class="keyword">AS</span> receiving_streamed_wal </span><br><span class="line"><span class="keyword">FROM</span> ( </span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">AS</span> ts, </span><br><span class="line">		pg_catalog.pg_last_wal_receive_lsn()       <span class="keyword">AS</span> last_wal_receive_lsn, </span><br><span class="line">		pg_catalog.pg_last_wal_replay_lsn()        <span class="keyword">AS</span> last_wal_replay_lsn, </span><br><span class="line">		pg_catalog.pg_last_xact_replay_timestamp() <span class="keyword">AS</span> last_xact_replay_timestamp </span><br><span class="line">) q ;</span><br><span class="line">-[ RECORD 1 ]<span class="comment">--------------+------------------------------</span></span><br><span class="line">ts                         | 2019-01-08 13:18:19.961552+08</span><br><span class="line">last_wal_receive_lsn       | 0/202ADAC0</span><br><span class="line">last_wal_replay_lsn        | 0/202AB940</span><br><span class="line">last_xact_replay_timestamp | 2019-01-08 13:11:47.534904+08</span><br><span class="line">replication_lag_time       | 392</span><br><span class="line">receiving_streamed_wal     | t</span><br></pre></td></tr></table></figure>

<h3 id="基于时间点恢复（PITR）"><a href="#基于时间点恢复（PITR）" class="headerlink" title="基于时间点恢复（PITR）"></a>基于时间点恢复（PITR）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> primary</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> postgresql.conf</span></span><br><span class="line">archive_mode = on</span><br><span class="line">archive_command = 'ssh young-90 test ! -f /work/pgsql/pgsql-11-stable/archives/%f &amp;&amp; scp %p young-90:/work/pgsql/pgsql-11-stable/archives/%f'</span><br></pre></td></tr></table></figure>

<p>创建表添加几条测试数据。</p>
<p>正常情况下，wal日志段在达到16M后会自动归档，由于测试我们使用手动切换归档。 </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- primary</span></span><br><span class="line">postgres=<span class="comment"># CREATE TABLE test_pitr(id int, ts timestamp);</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span></span><br><span class="line">postgres=<span class="comment"># SELECT pg_switch_wal();</span></span><br><span class="line"> pg_switch_wal </span><br><span class="line"><span class="comment">---------------</span></span><br><span class="line"> <span class="number">0</span>/<span class="number">3017568</span></span><br><span class="line">(<span class="number">1</span> <span class="keyword">row</span>)</span><br><span class="line"></span><br><span class="line">postgres=<span class="comment"># INSERT INTO test_pitr VALUES (1, now());</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">postgres=<span class="comment"># INSERT INTO test_pitr VALUES (2, now());</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">postgres=<span class="comment"># SELECT * FROM test_pitr ;</span></span><br><span class="line"> <span class="keyword">id</span> |             ts             </span><br><span class="line"><span class="comment">----+----------------------------</span></span><br><span class="line">  <span class="number">1</span> | <span class="number">2019</span><span class="number">-01</span><span class="number">-08</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">57.734731</span></span><br><span class="line">  <span class="number">2</span> | <span class="number">2019</span><span class="number">-01</span><span class="number">-08</span> <span class="number">14</span>:<span class="number">23</span>:<span class="number">00.598715</span></span><br><span class="line">(<span class="number">2</span> <span class="keyword">rows</span>)</span><br><span class="line"></span><br><span class="line">postgres=<span class="comment"># SELECT pg_switch_wal();</span></span><br><span class="line"> pg_switch_wal </span><br><span class="line"><span class="comment">---------------</span></span><br><span class="line"> <span class="number">0</span>/<span class="number">4000190</span></span><br><span class="line">(<span class="number">1</span> <span class="keyword">row</span>)</span><br><span class="line"></span><br><span class="line">postgres=<span class="comment"># INSERT INTO test_pitr VALUES (3, now());</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">postgres=<span class="comment"># INSERT INTO test_pitr VALUES (4, now());</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">postgres=<span class="comment"># SELECT * FROM test_pitr ;</span></span><br><span class="line"> <span class="keyword">id</span> |             ts             </span><br><span class="line"><span class="comment">----+----------------------------</span></span><br><span class="line">  <span class="number">1</span> | <span class="number">2019</span><span class="number">-01</span><span class="number">-08</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">57.734731</span></span><br><span class="line">  <span class="number">2</span> | <span class="number">2019</span><span class="number">-01</span><span class="number">-08</span> <span class="number">14</span>:<span class="number">23</span>:<span class="number">00.598715</span></span><br><span class="line">  <span class="number">3</span> | <span class="number">2019</span><span class="number">-01</span><span class="number">-08</span> <span class="number">14</span>:<span class="number">23</span>:<span class="number">29.175027</span></span><br><span class="line">  <span class="number">4</span> | <span class="number">2019</span><span class="number">-01</span><span class="number">-08</span> <span class="number">14</span>:<span class="number">23</span>:<span class="number">32.25439</span></span><br><span class="line">(<span class="number">4</span> <span class="keyword">rows</span>)</span><br><span class="line">postgres=<span class="comment"># SELECT pg_switch_wal();</span></span><br><span class="line"> pg_switch_wal </span><br><span class="line"><span class="comment">---------------</span></span><br><span class="line"> <span class="number">0</span>/<span class="number">5000190</span></span><br><span class="line">(<span class="number">1</span> <span class="keyword">row</span>)</span><br><span class="line"></span><br><span class="line">postgres=<span class="comment"># INSERT INTO test_pitr VALUES (5, now());</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">postgres=<span class="comment"># INSERT INTO test_pitr VALUES (6, now());</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">postgres=<span class="comment"># SELECT * FROM test_pitr ;</span></span><br><span class="line"> <span class="keyword">id</span> |             ts             </span><br><span class="line"><span class="comment">----+----------------------------</span></span><br><span class="line">  <span class="number">1</span> | <span class="number">2019</span><span class="number">-01</span><span class="number">-08</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">57.734731</span></span><br><span class="line">  <span class="number">2</span> | <span class="number">2019</span><span class="number">-01</span><span class="number">-08</span> <span class="number">14</span>:<span class="number">23</span>:<span class="number">00.598715</span></span><br><span class="line">  <span class="number">3</span> | <span class="number">2019</span><span class="number">-01</span><span class="number">-08</span> <span class="number">14</span>:<span class="number">23</span>:<span class="number">29.175027</span></span><br><span class="line">  <span class="number">4</span> | <span class="number">2019</span><span class="number">-01</span><span class="number">-08</span> <span class="number">14</span>:<span class="number">23</span>:<span class="number">32.25439</span></span><br><span class="line">  <span class="number">5</span> | <span class="number">2019</span><span class="number">-01</span><span class="number">-08</span> <span class="number">14</span>:<span class="number">26</span>:<span class="number">57.560111</span></span><br><span class="line">  <span class="number">6</span> | <span class="number">2019</span><span class="number">-01</span><span class="number">-08</span> <span class="number">14</span>:<span class="number">27</span>:<span class="number">01.015577</span></span><br><span class="line">(<span class="number">6</span> <span class="keyword">rows</span>)</span><br><span class="line"></span><br><span class="line">postgres=<span class="comment"># SELECT pg_switch_wal();</span></span><br><span class="line"> pg_switch_wal </span><br><span class="line"><span class="comment">---------------</span></span><br><span class="line"> <span class="number">0</span>/<span class="number">6000358</span></span><br><span class="line">(<span class="number">1</span> <span class="keyword">row</span>)</span><br></pre></td></tr></table></figure>

<p>正常情况下，wal日志段在达到16M后会自动归档，由于测试我们使用手动切换归档。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> standby</span></span><br><span class="line">ll archives/</span><br><span class="line">total 98308</span><br><span class="line">-rw------- 1 yangjie yangjie 16777216 Jan  8 14:21 000000010000000000000001</span><br><span class="line">-rw------- 1 yangjie yangjie 16777216 Jan  8 14:21 000000010000000000000002</span><br><span class="line">-rw------- 1 yangjie yangjie      330 Jan  8 14:21 000000010000000000000002.00000028.backup</span><br><span class="line">-rw------- 1 yangjie yangjie 16777216 Jan  8 14:22 000000010000000000000003</span><br><span class="line">-rw------- 1 yangjie yangjie 16777216 Jan  8 14:23 000000010000000000000004</span><br><span class="line">-rw------- 1 yangjie yangjie 16777216 Jan  8 14:23 000000010000000000000005</span><br><span class="line">-rw------- 1 yangjie yangjie 16777216 Jan  8 14:27 000000010000000000000006</span><br></pre></td></tr></table></figure>

<p>修改备库配置文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> standby </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> recovery.conf</span></span><br><span class="line">standby_mode = 'off'</span><br><span class="line">primary_conninfo = 'host=''young-91'' user=repmgr application_name=young90 connect_timeout=2'</span><br><span class="line">recovery_target_time = '2019-01-08 14:26:00'</span><br><span class="line">restore_command = 'cp /work/pgsql/pgsql-11-stable/archives/%f %p'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> postgresql.conf</span></span><br><span class="line"><span class="meta">#</span><span class="bash">archive_mode = on</span></span><br><span class="line"><span class="meta">#</span><span class="bash">archive_command = <span class="string">'ssh young-90 test ! -f /work/pgsql/pgsql-11-stable/archives/%f &amp;&amp; scp %p young-90:/work/pgsql/pgsql-11-stable/archives/%f'</span></span></span><br></pre></td></tr></table></figure>

<p>重启备库</p>
<p>会进行PITR恢复到指定的时间点</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> standby</span></span><br><span class="line">[yangjie@young-90 bin]$ ./pg_ctl -D ../data/ start</span><br><span class="line">waiting for server to start....</span><br><span class="line">2019-01-08 14:29:33.364 CST [24910] LOG:  listening on IPv4 address "0.0.0.0", port 5432</span><br><span class="line">2019-01-08 14:29:33.364 CST [24910] LOG:  listening on IPv6 address "::", port 5432</span><br><span class="line">2019-01-08 14:29:33.366 CST [24910] LOG:  listening on Unix socket "/tmp/.s.PGSQL.5432"</span><br><span class="line">2019-01-08 14:29:33.385 CST [24911] LOG:  database system was interrupted while in recovery at log time 2019-01-08 14:21:30 CST</span><br><span class="line">2019-01-08 14:29:33.385 CST [24911] HINT:  If this has occurred more than once some data might be corrupted AND you might need to choose an earlier recovery target.</span><br><span class="line">2019-01-08 14:29:33.556 CST [24911] LOG:  starting point-in-time recovery to 2019-01-08 14:26:00+08</span><br><span class="line">2019-01-08 14:29:33.570 CST [24911] LOG:  restored log file "000000010000000000000002" FROM archive</span><br><span class="line">2019-01-08 14:29:33.585 CST [24911] LOG:  redo starts at 0/2000028</span><br><span class="line">2019-01-08 14:29:33.599 CST [24911] LOG:  restored log file "000000010000000000000003" FROM archive</span><br><span class="line">2019-01-08 14:29:33.630 CST [24911] LOG:  restored log file "000000010000000000000004" FROM archive</span><br><span class="line">2019-01-08 14:29:33.662 CST [24911] LOG:  restored log file "000000010000000000000005" FROM archive</span><br><span class="line">2019-01-08 14:29:33.694 CST [24911] LOG:  restored log file "000000010000000000000006" FROM archive</span><br><span class="line">2019-01-08 14:29:33.709 CST [24911] LOG:  consistent recovery state reached at 0/6000060</span><br><span class="line">2019-01-08 14:29:33.709 CST [24911] LOG:  recovery stopping before commit of transaction 584, time 2019-01-08 14:26:57.560463+08</span><br><span class="line">2019-01-08 14:29:33.709 CST [24911] LOG:  recovery has paused</span><br><span class="line">2019-01-08 14:29:33.709 CST [24911] HINT:  Execute pg_wal_replay_resume() to continue.</span><br><span class="line">2019-01-08 14:29:33.709 CST [24910] LOG:  database system is ready to accept read only connections</span><br><span class="line"> done</span><br><span class="line">server started</span><br><span class="line">[yangjie@young-90 bin]$ ./psql postgres</span><br><span class="line">psql (11.1)</span><br><span class="line">Type "help" for help.</span><br><span class="line"></span><br><span class="line">postgres=# SELECT * FROM test_pitr;</span><br><span class="line"> id |             ts             </span><br><span class="line">----+----------------------------</span><br><span class="line">  1 | 2019-01-08 14:22:57.734731</span><br><span class="line">  2 | 2019-01-08 14:23:00.598715</span><br><span class="line">  3 | 2019-01-08 14:23:29.175027</span><br><span class="line">  4 | 2019-01-08 14:23:32.25439</span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure>

<h3 id="闪回查询"><a href="#闪回查询" class="headerlink" title="闪回查询"></a>闪回查询</h3><p>闪回查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span> <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'jinan'</span>, <span class="keyword">now</span>());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">SELECT</span> xmin,xmax,* <span class="keyword">FROM</span> <span class="keyword">test</span> ;</span><br><span class="line"> xmin | xmax | id |  tx   |             ts             </span><br><span class="line"><span class="comment">------+------+----+-------+----------------------------</span></span><br><span class="line">  638 |    0 |  1 | jinan | 2018-07-26 11:12:09.749414</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">test</span> <span class="keyword">SET</span> tx = <span class="string">'hangzhou'</span>, ts = <span class="keyword">now</span>() <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">SELECT</span> xmin,xmax,* <span class="keyword">FROM</span> <span class="keyword">test</span> ;</span><br><span class="line"> xmin | xmax | id |    tx    |            ts             </span><br><span class="line"><span class="comment">------+------+----+----------+---------------------------</span></span><br><span class="line">  639 |    0 |  1 | hangzhou | 2018-07-26 11:12:26.66156</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">test</span> <span class="keyword">SET</span> tx = <span class="string">'beijing'</span>, ts = <span class="keyword">now</span>() <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">SELECT</span> xmin,xmax,* <span class="keyword">FROM</span> <span class="keyword">test</span> ;</span><br><span class="line"> xmin | xmax | id |   tx    |             ts             </span><br><span class="line"><span class="comment">------+------+----+---------+----------------------------</span></span><br><span class="line">  640 |    0 |  1 | beijing | 2018-07-26 11:12:36.117637</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 指定时间点闪回查询</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">test</span> <span class="keyword">AS</span> <span class="keyword">OF</span> <span class="built_in">TIMESTAMP</span> <span class="string">'2018-07-26 11:12:10'</span>;</span><br><span class="line"> id |  tx   |             ts             </span><br><span class="line"><span class="comment">----+-------+----------------------------</span></span><br><span class="line">  1 | jinan | 2018-07-26 11:12:09.749414</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">test</span> <span class="keyword">AS</span> <span class="keyword">OF</span> <span class="built_in">TIMESTAMP</span> <span class="string">'2018-07-26 11:12:30'</span>;</span><br><span class="line"> id |    tx    |            ts             </span><br><span class="line"><span class="comment">----+----------+---------------------------</span></span><br><span class="line">  1 | hangzhou | 2018-07-26 11:12:26.66156</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 指定事务号闪回查询</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">test</span> <span class="keyword">AS</span> <span class="keyword">OF</span> XID <span class="number">638</span>;</span><br><span class="line"> id |  tx   |             ts             </span><br><span class="line"><span class="comment">----+-------+----------------------------</span></span><br><span class="line">  1 | jinan | 2018-07-26 11:12:09.749414</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">test</span> <span class="keyword">AS</span> <span class="keyword">OF</span> XID <span class="number">639</span>;</span><br><span class="line"> id |    tx    |            ts             </span><br><span class="line"><span class="comment">----+----------+---------------------------</span></span><br><span class="line">  1 | hangzhou | 2018-07-26 11:12:26.66156</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>闪回版本查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 指定时间段闪回版本查询</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">test</span> </span><br><span class="line"><span class="keyword">VERSIONS</span> <span class="keyword">BETWEEN</span> <span class="built_in">TIMESTAMP</span> </span><br><span class="line">	<span class="string">'2018-07-26 11:12:05'</span> </span><br><span class="line">	<span class="keyword">AND</span> <span class="string">'2018-07-26 11:12:40'</span> </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"> id |    tx    |             ts             </span><br><span class="line"><span class="comment">----+----------+----------------------------</span></span><br><span class="line">  1 | jinan    | 2018-07-26 11:12:09.749414</span><br><span class="line">  1 | hangzhou | 2018-07-26 11:12:26.66156</span><br><span class="line">  1 | beijing  | 2018-07-26 11:12:36.117637</span><br><span class="line">(3 rows)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">test</span> </span><br><span class="line"><span class="keyword">VERSIONS</span> <span class="keyword">BETWEEN</span> <span class="built_in">TIMESTAMP</span> </span><br><span class="line">	<span class="string">'2018-07-26 11:12:05'</span> </span><br><span class="line">	<span class="keyword">AND</span> <span class="string">'2018-07-26 11:12:30'</span> </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"> id |    tx    |             ts             </span><br><span class="line"><span class="comment">----+----------+----------------------------</span></span><br><span class="line">  1 | jinan    | 2018-07-26 11:12:09.749414</span><br><span class="line">  1 | hangzhou | 2018-07-26 11:12:26.66156</span><br><span class="line">(2 rows)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 指定事务号闪回版本查询</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">test</span> </span><br><span class="line"><span class="keyword">VERSIONS</span> <span class="keyword">BETWEEN</span> XID  </span><br><span class="line">	<span class="number">638</span> <span class="keyword">AND</span> <span class="number">640</span> </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"> id |    tx    |             ts             </span><br><span class="line"><span class="comment">----+----------+----------------------------</span></span><br><span class="line">  1 | jinan    | 2018-07-26 11:12:09.749414</span><br><span class="line">  1 | hangzhou | 2018-07-26 11:12:26.66156</span><br><span class="line">  1 | beijing  | 2018-07-26 11:12:36.117637</span><br><span class="line">(3 rows)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">test</span> </span><br><span class="line"><span class="keyword">VERSIONS</span> <span class="keyword">BETWEEN</span> XID</span><br><span class="line">	<span class="number">638</span> <span class="keyword">AND</span> <span class="number">639</span> </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"> id |    tx    |             ts             </span><br><span class="line"><span class="comment">----+----------+----------------------------</span></span><br><span class="line">  1 | jinan    | 2018-07-26 11:12:09.749414</span><br><span class="line">  1 | hangzhou | 2018-07-26 11:12:26.66156</span><br><span class="line">(2 rows)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 一个事务中多次修改</span></span><br><span class="line"><span class="keyword">SELECT</span> xmin,xmax,* <span class="keyword">FROM</span> <span class="keyword">test</span>;</span><br><span class="line"> xmin | xmax | id |   tx    |             ts             </span><br><span class="line"><span class="comment">------+------+----+---------+----------------------------</span></span><br><span class="line">  648 |    0 |  1 | beijing | 2018-07-26 13:35:24.015878</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">test</span> <span class="keyword">SET</span> tx = <span class="string">'jinan'</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">test</span> <span class="keyword">SET</span> tx = <span class="string">'hangzhou'</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">COMMIT</span></span><br><span class="line"><span class="keyword">SELECT</span> xmin,xmax,* <span class="keyword">FROM</span> <span class="keyword">test</span>;</span><br><span class="line"> xmin | xmax | id |    tx    |             ts             </span><br><span class="line"><span class="comment">------+------+----+----------+----------------------------</span></span><br><span class="line">  649 |    0 |  1 | hangzhou | 2018-07-26 13:35:24.015878</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> xmin,xmax,* <span class="keyword">FROM</span> <span class="keyword">test</span> </span><br><span class="line"><span class="keyword">VERSIONS</span> <span class="keyword">BETWEEN</span> <span class="built_in">TIMESTAMP</span></span><br><span class="line">	<span class="string">'2018-07-26 13:35:00'</span> </span><br><span class="line">	<span class="keyword">AND</span> <span class="string">'2018-07-26 13:37:00'</span>;</span><br><span class="line"> xmin | xmax | id |    tx    |             ts             </span><br><span class="line"><span class="comment">------+------+----+----------+----------------------------</span></span><br><span class="line">  648 |  649 |  1 | beijing  | 2018-07-26 13:35:24.015878</span><br><span class="line">  649 |    0 |  1 | hangzhou | 2018-07-26 13:35:24.015878</span><br><span class="line">(2 rows)</span><br><span class="line"><span class="comment">-- jinan并不是一个版本，因为没有提交</span></span><br></pre></td></tr></table></figure>



<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://repmgr.org/" target="_blank" rel="noopener">https://repmgr.org/</a></p>
<p><a href="https://www.postgresql.org/docs/current/standby-settings.html" target="_blank" rel="noopener">https://www.postgresql.org/docs/current/standby-settings.html</a></p>
<p><a href="https://www.postgresql.org/docs/current/continuous-archiving.html" target="_blank" rel="noopener">https://www.postgresql.org/docs/current/continuous-archiving.html</a></p>
<p><a href="https://www.postgresql.org/message-id/88AAF14A-0D49-4538-9C63-58535CF6686C@highgo.com" target="_blank" rel="noopener">https://www.postgresql.org/message-id/88AAF14A-0D49-4538-9C63-58535CF6686C@highgo.com</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.yonj1e.top/2018/08/20/c-language-func/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="Yang Jie">
      <meta itemprop="description" content="Stay hungry, Stay young">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yonj1e's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/20/c-language-func/" class="post-title-link" itemprop="url">PostgreSQL中的C语言函数</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-20 00:00:00" itemprop="dateCreated datePublished" datetime="2018-08-20T00:00:00+00:00">2018-08-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-18 14:11:26" itemprop="dateModified" datetime="2020-07-18T14:11:26+00:00">2020-07-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/" itemprop="url" rel="index">
                    <span itemprop="name">PostgreSQL</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://www.postgresql.org/docs/current/static/xfunc-c.html" target="_blank" rel="noopener">官方文档</a></p>
<p>之前在做定时任务时，用到了C语言函数。</p>
<p>contrib目录下很多插件都是用到了c语言函数。</p>
<p>以扩展中使用c语言函数为例：</p>
<ol>
<li>sql文件创建函数</li>
<li>c文件编写函数实现</li>
<li>编译扩展生成.so文件，create extension时调用sql创建函数。</li>
</ol>
<h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CREATE FUNCTION <span class="title">xfunc_add</span><span class="params">(bigint, bigint)</span></span></span><br><span class="line"><span class="function">RETURNS bigint </span></span><br><span class="line">AS '$libdir/xfunc', 'xfunc_add'</span><br><span class="line">LANGUAGE C STRICT;</span><br></pre></td></tr></table></figure>

<p>$libdir/xfunc是生成的xfunc.so的路径，xfunc就是指xfunc.so文件，xfunc_add是C函数中的函数名</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//xfunc.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"postgres.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fmgr.h"</span></span></span><br><span class="line"></span><br><span class="line">PG_MODULE_MAGIC;</span><br><span class="line"></span><br><span class="line">PG_FUNCTION_INFO_V1(xfunc_add);</span><br><span class="line"></span><br><span class="line">Datum</span><br><span class="line">xfunc_add(PG_FUNCTION_ARGS)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">int</span>     a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>     b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>     c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        a = PG_GETARG_INT32(<span class="number">0</span>);</span><br><span class="line">        b = PG_GETARG_INT32(<span class="number">1</span>);</span><br><span class="line">        c = a + b;c</span><br><span class="line">        PG_RETURN_INT32(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从PostgreSQL 8.2 开始，动态 载入的函数要求有一个magic block。要包括一个 magic block，在写上包括 头文件fmgr.h的语句之后，在该模块的源文件写上一下内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PG_MODULE_MAGIC</span></span><br><span class="line"></span><br><span class="line">PG_MODULE_MAGIC;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>如果代码不需要针对 8.2 之前的PostgreSQL 发行版进行编译，则#ifdef可以省略</p>
<h2 id="官方示例worker-spi"><a href="#官方示例worker-spi" class="headerlink" title="官方示例worker_spi"></a>官方示例worker_spi</h2><p>这个示例实际是spi_conn和动态创建扩展的示例。</p>
<p>关于bgworker的介绍及开发可看这篇<a href="https://yonj1e.github.io/young/bgworker/" target="_blank" rel="noopener">博客</a>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* src/test/modules/worker_spi/worker_spi--1.0.sql */</span></span><br><span class="line"></span><br><span class="line">-- complain <span class="keyword">if</span> script is sourced in psql, rather than via CREATE EXTENSION</span><br><span class="line">\echo Use <span class="string">"CREATE EXTENSION worker_spi"</span> to load <span class="keyword">this</span> file. \quit</span><br><span class="line"></span><br><span class="line"><span class="function">CREATE FUNCTION <span class="title">worker_spi_launch</span><span class="params">(bigint)</span></span></span><br><span class="line"><span class="function">RETURNS bigint STRICT</span></span><br><span class="line">AS 'MODULE_PATHNAME'</span><br><span class="line">LANGUAGE C;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"postgres.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* These are always necessary for a bgworker */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"miscadmin.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"postmaster/bgworker.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"storage/ipc.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"storage/latch.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"storage/lwlock.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"storage/proc.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"storage/shmem.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* these headers are used by this particular worker's code */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"access/xact.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"executor/spi.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fmgr.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lib/stringinfo.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pgstat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"utils/builtins.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"utils/snapmgr.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tcop/utility.h"</span></span></span><br><span class="line"></span><br><span class="line">PG_MODULE_MAGIC;</span><br><span class="line"></span><br><span class="line">PG_FUNCTION_INFO_V1(worker_spi_launch);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Dynamically launch an SPI worker.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Datum</span><br><span class="line">worker_spi_launch(PG_FUNCTION_ARGS)</span><br><span class="line">&#123;</span><br><span class="line">	int32		i = PG_GETARG_INT32(<span class="number">0</span>);</span><br><span class="line">	BackgroundWorker worker;</span><br><span class="line">	BackgroundWorkerHandle *handle;</span><br><span class="line">	BgwHandleStatus status;</span><br><span class="line">	<span class="keyword">pid_t</span>		pid;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(&amp;worker, <span class="number">0</span>, <span class="keyword">sizeof</span>(worker));</span><br><span class="line">	worker.bgw_flags = BGWORKER_SHMEM_ACCESS |</span><br><span class="line">		BGWORKER_BACKEND_DATABASE_CONNECTION;</span><br><span class="line">	worker.bgw_start_time = BgWorkerStart_RecoveryFinished;</span><br><span class="line">	worker.bgw_restart_time = BGW_NEVER_RESTART;</span><br><span class="line">	<span class="built_in">sprintf</span>(worker.bgw_library_name, <span class="string">"worker_spi"</span>);</span><br><span class="line">	<span class="built_in">sprintf</span>(worker.bgw_function_name, <span class="string">"worker_spi_main"</span>);</span><br><span class="line">	<span class="built_in">snprintf</span>(worker.bgw_name, BGW_MAXLEN, <span class="string">"worker %d"</span>, i);</span><br><span class="line">	worker.bgw_main_arg = Int32GetDatum(i);</span><br><span class="line">	<span class="comment">/* set bgw_notify_pid so that we can use WaitForBackgroundWorkerStartup */</span></span><br><span class="line">	worker.bgw_notify_pid = MyProcPid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!RegisterDynamicBackgroundWorker(&amp;worker, &amp;handle))</span><br><span class="line">		PG_RETURN_NULL();</span><br><span class="line"></span><br><span class="line">	status = WaitForBackgroundWorkerStartup(handle, &amp;pid);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (status == BGWH_STOPPED)</span><br><span class="line">		ereport(ERROR,</span><br><span class="line">				(errcode(ERRCODE_INSUFFICIENT_RESOURCES),</span><br><span class="line">				 errmsg(<span class="string">"could not start background process"</span>),</span><br><span class="line">				 errhint(<span class="string">"More details may be available in the server log."</span>)));</span><br><span class="line">	<span class="keyword">if</span> (status == BGWH_POSTMASTER_DIED)</span><br><span class="line">		ereport(ERROR,</span><br><span class="line">				(errcode(ERRCODE_INSUFFICIENT_RESOURCES),</span><br><span class="line">				 errmsg(<span class="string">"cannot start background processes without postmaster"</span>),</span><br><span class="line">				 errhint(<span class="string">"Kill all remaining database processes and restart the database."</span>)));</span><br><span class="line">	Assert(status == BGWH_STARTED);</span><br><span class="line"></span><br><span class="line">	PG_RETURN_INT32(pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="触发器函数"><a href="#触发器函数" class="headerlink" title="触发器函数"></a>触发器函数</h2><p><a href="https://www.postgresql.org/docs/12/trigger-interface.html" target="_blank" rel="noopener">Writing Trigger Functions in C</a></p>
<p>在规则表发生变化时，出发reload,j将数据更新到内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE FUNCTION check_balance.cb_reload()</span><br><span class="line">RETURNS trigger</span><br><span class="line">AS '$libdir/check_balance', 'cb_reload'</span><br><span class="line">LANGUAGE C ;</span><br><span class="line"></span><br><span class="line">CREATE TRIGGER cb_rules_changes</span><br><span class="line">after INSERT OR UPDATE OR DELETE</span><br><span class="line">ON check_balance.rules FOR EACH ROW</span><br><span class="line">EXECUTE PROCEDURE check_balance.cb_reload();</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">PG_FUNCTION_INFO_V1(cb_reload);</span><br><span class="line"><span class="function">Datum <span class="title">cb_reload</span><span class="params">(PG_FUNCTION_ARGS)</span></span>;</span><br><span class="line"></span><br><span class="line">Datum</span><br><span class="line">cb_reload(PG_FUNCTION_ARGS)</span><br><span class="line">&#123;</span><br><span class="line">	TriggerData	*trigdata = (TriggerData *) fcinfo-&gt;context;</span><br><span class="line">	TupleDesc	tupdesc;</span><br><span class="line">	HeapTuple	rettuple;</span><br><span class="line">	HeapTuple	newtuple;</span><br><span class="line">	HeapTuple	trigtuple;</span><br><span class="line">	HeapTuple	spi_tuple;</span><br><span class="line">	SPITupleTable *spi_tuptable;</span><br><span class="line">	TupleDesc spi_tupdesc;</span><br><span class="line">	<span class="keyword">int</span>		ret;</span><br><span class="line">	<span class="keyword">int</span>		ntup;</span><br><span class="line">	<span class="keyword">int</span>		i, j;</span><br><span class="line">	StringInfoData	buf;</span><br><span class="line">	<span class="keyword">char</span>		**tup = <span class="literal">NULL</span>;</span><br><span class="line">	ruledesc        *rules = <span class="literal">NULL</span>; </span><br><span class="line">	<span class="keyword">bool</span>		isupdate, isinsert, isdelete;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* make sure it's called as a trigger at all */</span></span><br><span class="line">	<span class="keyword">if</span> (!CALLED_AS_TRIGGER(fcinfo))</span><br><span class="line">		elog(ERROR, <span class="string">"trigf: not called by trigger manager"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* tuple to return to executor */</span></span><br><span class="line">	<span class="keyword">if</span> (TRIGGER_FIRED_BY_UPDATE(trigdata-&gt;tg_event))</span><br><span class="line">		rettuple = trigdata-&gt;tg_newtuple;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		rettuple = trigdata-&gt;tg_trigtuple;</span><br><span class="line"></span><br><span class="line">	tupdesc = trigdata-&gt;tg_relation-&gt;rd_att;</span><br><span class="line">	newtuple = trigdata-&gt;tg_newtuple;</span><br><span class="line">	trigtuple = trigdata-&gt;tg_trigtuple;</span><br><span class="line"></span><br><span class="line">	SPI_connect();</span><br><span class="line"></span><br><span class="line">	isupdate = TRIGGER_FIRED_BY_UPDATE(trigdata-&gt;tg_event);</span><br><span class="line">	isdelete = TRIGGER_FIRED_BY_DELETE(trigdata-&gt;tg_event);</span><br><span class="line">	isinsert = TRIGGER_FIRED_BY_INSERT(trigdata-&gt;tg_event);</span><br><span class="line">	</span><br><span class="line">	initStringInfo(&amp;buf);</span><br><span class="line">	<span class="keyword">if</span> (isupdate)</span><br><span class="line">	&#123;</span><br><span class="line">		appendStringInfo(&amp;buf, <span class="string">"select * from check_balance.rules where id != %s;"</span>, </span><br><span class="line">						SPI_getvalue(newtuple, tupdesc, <span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (isdelete)</span><br><span class="line">	&#123;</span><br><span class="line">		appendStringInfo(&amp;buf, <span class="string">"select * from check_balance.rules where id != %s;"</span>,</span><br><span class="line">						SPI_getvalue(trigtuple, tupdesc, <span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (isinsert)</span><br><span class="line">	&#123;</span><br><span class="line">		appendStringInfoString(&amp;buf, <span class="string">"select * from check_balance.rules;"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = SPI_execute(buf.data, <span class="literal">true</span>, <span class="number">0</span>);</span><br><span class="line">	pfree(buf.data);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret != SPI_OK_SELECT)</span><br><span class="line">		elog(FATAL, <span class="string">"SPI_execute failed: error code %d"</span>, ret);</span><br><span class="line"></span><br><span class="line">	ntup = SPI_processed;</span><br><span class="line"></span><br><span class="line">	tup = (<span class="keyword">char</span>**)palloc0(<span class="keyword">sizeof</span>(<span class="keyword">char</span>*) * tupdesc-&gt;natts);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ntup != <span class="number">0</span> &amp;&amp; SPI_tuptable != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		spi_tuptable = SPI_tuptable;</span><br><span class="line">		spi_tupdesc = spi_tuptable-&gt;tupdesc;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ntup; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			rules = &amp;rd[j];</span><br><span class="line">			spi_tuple = spi_tuptable-&gt;vals[j];</span><br><span class="line"></span><br><span class="line">			<span class="built_in">memset</span>(&amp;rd[j], <span class="number">0</span>, <span class="keyword">sizeof</span>(ruledesc));</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= spi_tupdesc-&gt;natts; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				tup[i<span class="number">-1</span>] = SPI_getvalue(spi_tuple, spi_tupdesc, i);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">memcpy</span>(rules-&gt;username, pstrdup(tup[<span class="number">1</span>]), <span class="built_in">strlen</span>(pstrdup(tup[<span class="number">1</span>])));</span><br><span class="line">			<span class="built_in">memcpy</span>(rules-&gt;startime, pstrdup(tup[<span class="number">2</span>]), <span class="built_in">strlen</span>(pstrdup(tup[<span class="number">2</span>])));</span><br><span class="line">			<span class="built_in">memcpy</span>(rules-&gt;endtime, pstrdup(tup[<span class="number">3</span>]), <span class="built_in">strlen</span>(pstrdup(tup[<span class="number">3</span>])));</span><br><span class="line">			<span class="built_in">memcpy</span>(rules-&gt;datname, pstrdup(tup[<span class="number">4</span>]), <span class="built_in">strlen</span>(pstrdup(tup[<span class="number">4</span>])));</span><br><span class="line">			<span class="built_in">memcpy</span>(rules-&gt;relnsp, pstrdup(tup[<span class="number">5</span>]), <span class="built_in">strlen</span>(pstrdup(tup[<span class="number">5</span>])));</span><br><span class="line">			<span class="built_in">memcpy</span>(rules-&gt;relname, pstrdup(tup[<span class="number">6</span>]), <span class="built_in">strlen</span>(pstrdup(tup[<span class="number">6</span>])));</span><br><span class="line">			<span class="built_in">memcpy</span>(rules-&gt;cmdtype, pstrdup(tup[<span class="number">7</span>]), <span class="built_in">strlen</span>(pstrdup(tup[<span class="number">7</span>])));</span><br><span class="line"></span><br><span class="line">			*tup = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">			elog(LOG, <span class="string">"w:%d,%s,%s,%s,%s,%s,%s,%s"</span>, </span><br><span class="line">				j,rules-&gt;username,rules-&gt;startime,rules-&gt;endtime,</span><br><span class="line">				rules-&gt;datname,rules-&gt;relnsp,rules-&gt;relname,rules-&gt;cmdtype);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment"> 	 * trigger record</span></span><br><span class="line"><span class="comment"> 	 */</span> </span><br><span class="line">	<span class="keyword">if</span> (isupdate || isinsert)</span><br><span class="line">	&#123;</span><br><span class="line">		rules = &amp;rd[ntup];</span><br><span class="line"></span><br><span class="line">		<span class="built_in">memset</span>(&amp;rd[ntup], <span class="number">0</span>, <span class="keyword">sizeof</span>(ruledesc));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= tupdesc-&gt;natts; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (isupdate)</span><br><span class="line">				tup[i<span class="number">-1</span>] = SPI_getvalue(newtuple, tupdesc, i);</span><br><span class="line">			<span class="keyword">if</span> (isinsert)</span><br><span class="line">				tup[i<span class="number">-1</span>] = SPI_getvalue(trigtuple, tupdesc, i);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">memcpy</span>(rules-&gt;username, pstrdup(tup[<span class="number">1</span>]), <span class="built_in">strlen</span>(pstrdup(tup[<span class="number">1</span>])));</span><br><span class="line">		<span class="built_in">memcpy</span>(rules-&gt;startime, pstrdup(tup[<span class="number">2</span>]), <span class="built_in">strlen</span>(pstrdup(tup[<span class="number">2</span>])));</span><br><span class="line">		<span class="built_in">memcpy</span>(rules-&gt;endtime, pstrdup(tup[<span class="number">3</span>]), <span class="built_in">strlen</span>(pstrdup(tup[<span class="number">3</span>])));</span><br><span class="line">		<span class="built_in">memcpy</span>(rules-&gt;datname, pstrdup(tup[<span class="number">4</span>]), <span class="built_in">strlen</span>(pstrdup(tup[<span class="number">4</span>])));</span><br><span class="line">		<span class="built_in">memcpy</span>(rules-&gt;relnsp, pstrdup(tup[<span class="number">5</span>]), <span class="built_in">strlen</span>(pstrdup(tup[<span class="number">5</span>])));</span><br><span class="line">		<span class="built_in">memcpy</span>(rules-&gt;relname, pstrdup(tup[<span class="number">6</span>]), <span class="built_in">strlen</span>(pstrdup(tup[<span class="number">6</span>])));</span><br><span class="line">		<span class="built_in">memcpy</span>(rules-&gt;cmdtype, pstrdup(tup[<span class="number">7</span>]), <span class="built_in">strlen</span>(pstrdup(tup[<span class="number">7</span>])));</span><br><span class="line"></span><br><span class="line">		*tup = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		elog(LOG, <span class="string">"w:%d,%s,%s,%s,%s,%s,%s,%s"</span>,</span><br><span class="line">			ntup,rules-&gt;username,rules-&gt;startime,rules-&gt;endtime,</span><br><span class="line">			rules-&gt;datname,rules-&gt;relnsp,rules-&gt;relname,rules-&gt;cmdtype);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SPI_finish();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> PointerGetDatum(rettuple);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.yonj1e.top/2017/08/11/hash-partition-in-pg10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="Yang Jie">
      <meta itemprop="description" content="Stay hungry, Stay young">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yonj1e's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/08/11/hash-partition-in-pg10/" class="post-title-link" itemprop="url">基于PostgreSQL10实现hash分区</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-08-11 00:00:00" itemprop="dateCreated datePublished" datetime="2017-08-11T00:00:00+00:00">2017-08-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-18 14:11:26" itemprop="dateModified" datetime="2020-07-18T14:11:26+00:00">2020-07-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/" itemprop="url" rel="index">
                    <span itemprop="name">PostgreSQL</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>基于pg10实现hash分区，下面介绍参照range/list分区实现的hash分区。</p>
<p>注意：由于本人水平限制，难免会有遗漏及错误的地方，不保证正确性，并且是个人见解，发现问题欢迎留言指正。</p>
<p>思路</p>
<ul>
<li><p>语法尽可能与range/list分区相似，先创建主表，再创建分区。</p>
</li>
<li><p>inser时对key值进行hash算法对分区数取余，找到要插入的分区。</p>
</li>
<li><p>可动态添加分区，当分区中有数据并新创建分区时，数据重新计算并分发。</p>
</li>
<li><p>select时约束排除使用相同的算法过滤分区。</p>
</li>
</ul>
<h2 id="建表语法"><a href="#建表语法" class="headerlink" title="建表语法"></a>建表语法</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">yonj1e=<span class="comment"># create table h (h_id int, h_name name, h_date date) partition by hash(h_id);</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span></span><br><span class="line">yonj1e=<span class="comment"># create table h1 partition of h;</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span></span><br><span class="line">yonj1e=<span class="comment"># create table h2 partition of h;</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span></span><br><span class="line">yonj1e=<span class="comment"># create table h3 partition of h;</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span></span><br><span class="line">yonj1e=<span class="comment"># create table h4 partition of h;</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span></span><br></pre></td></tr></table></figure>
<p>建主表的语法与range/list分区一样，只有类型差别。</p>
<p>子表不需要想range/list分区那样的约束，因此不需要额外的说明，创建后，会将分区key值信息记录到pg_class.relpartbound。</p>
<p>创建主表时做了两个主要修改以识别主表的创建：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/src/include/nodes/parsenodes.h</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PARTITION_STRATEGY_HASH        <span class="meta-string">'h'</span></span></span><br><span class="line"></span><br><span class="line">/src/backend/commands/tablecmds.c</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (pg_strcasecmp(partspec-&gt;strategy, <span class="string">"hash"</span>) == <span class="number">0</span>)</span><br><span class="line">        *strategy = PARTITION_STRATEGY_HASH;</span><br></pre></td></tr></table></figure>
<p>创建子表时修改ForValue 为EMPTY时即为创建hash partition：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/src/backend/parser/gram.y</span><br><span class="line"><span class="comment">/* a HASH partition */</span></span><br><span class="line">            |  <span class="comment">/*EMPTY*/</span></span><br><span class="line">                &#123;</span><br><span class="line">                    PartitionBoundSpec *n = makeNode(PartitionBoundSpec);</span><br><span class="line"></span><br><span class="line">                    n-&gt;strategy = PARTITION_STRATEGY_HASH;</span><br><span class="line">                    <span class="comment">//n-&gt;hashnumber = 1;</span></span><br><span class="line">                    <span class="comment">//n-&gt;location = @3;</span></span><br><span class="line"></span><br><span class="line">                    $$ = n;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>insert时，做的修改也是在range/list分区基础上做的修改，增加的代码不多，代码在parition.c文件get_partition_for_tuple()，根据value值计算出目标分区，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cur_index = DatumGetUInt32(OidFunctionCall1(get_hashfunc_oid(key-&gt;parttypid[<span class="number">0</span>]), values[<span class="number">0</span>])) % nparts;</span><br></pre></td></tr></table></figure>
<p>本hash partition实现方式不需要事先确定好几个分区，可随时添加分区，这里需要考虑到如果分区中已经有数据的情况，当分区中有数据，如果新创建一个分区，分区数发生变化，计算出来的目标分区也就改变，同样的数据在不同的分区这样显然是不合理的，所以需要在创建新分区的时候对已有的数据重新进行计算并插入目标分区。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># insert into h select generate_series(1,20);</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="number">0</span> <span class="number">20</span></span><br><span class="line">postgres=<span class="comment"># select tableoid::regclass,* from h;</span></span><br><span class="line"> tableoid | <span class="keyword">id</span> </span><br><span class="line"><span class="comment">----------+----</span></span><br><span class="line"> h1       |  <span class="number">1</span></span><br><span class="line"> h1       |  <span class="number">2</span></span><br><span class="line"> h1       |  <span class="number">5</span></span><br><span class="line"> h1       |  <span class="number">6</span></span><br><span class="line"> h1       |  <span class="number">8</span></span><br><span class="line"> h1       |  <span class="number">9</span></span><br><span class="line"> h1       | <span class="number">12</span></span><br><span class="line"> h1       | <span class="number">13</span></span><br><span class="line"> h1       | <span class="number">15</span></span><br><span class="line"> h1       | <span class="number">17</span></span><br><span class="line"> h1       | <span class="number">19</span></span><br><span class="line"> h2       |  <span class="number">3</span></span><br><span class="line"> h2       |  <span class="number">4</span></span><br><span class="line"> h2       |  <span class="number">7</span></span><br><span class="line"> h2       | <span class="number">10</span></span><br><span class="line"> h2       | <span class="number">11</span></span><br><span class="line"> h2       | <span class="number">14</span></span><br><span class="line"> h2       | <span class="number">16</span></span><br><span class="line"> h2       | <span class="number">18</span></span><br><span class="line"> h2       | <span class="number">20</span></span><br><span class="line">(<span class="number">20</span> <span class="keyword">rows</span>)</span><br><span class="line"></span><br><span class="line">postgres=<span class="comment"># create table h3 partition of h;</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span></span><br><span class="line">postgres=<span class="comment"># select tableoid::regclass,* from h;</span></span><br><span class="line"> tableoid | <span class="keyword">id</span> </span><br><span class="line"><span class="comment">----------+----</span></span><br><span class="line"> h1       |  <span class="number">5</span></span><br><span class="line"> h1       | <span class="number">17</span></span><br><span class="line"> h1       | <span class="number">19</span></span><br><span class="line"> h1       |  <span class="number">3</span></span><br><span class="line"> h2       |  <span class="number">7</span></span><br><span class="line"> h2       | <span class="number">11</span></span><br><span class="line"> h2       | <span class="number">14</span></span><br><span class="line"> h2       | <span class="number">18</span></span><br><span class="line"> h2       | <span class="number">20</span></span><br><span class="line"> h2       |  <span class="number">2</span></span><br><span class="line"> h2       |  <span class="number">6</span></span><br><span class="line"> h2       | <span class="number">12</span></span><br><span class="line"> h2       | <span class="number">15</span></span><br><span class="line"> h3       |  <span class="number">1</span></span><br><span class="line"> h3       |  <span class="number">8</span></span><br><span class="line"> h3       |  <span class="number">9</span></span><br><span class="line"> h3       | <span class="number">13</span></span><br><span class="line"> h3       |  <span class="number">4</span></span><br><span class="line"> h3       | <span class="number">10</span></span><br><span class="line"> h3       | <span class="number">16</span></span><br><span class="line">(<span class="number">20</span> <span class="keyword">rows</span>)</span><br><span class="line"></span><br><span class="line">postgres=<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<h2 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h2><p>这里主要修改查询规划部分，在relation_excluded_by_constraints函数中添加对hash分区的过滤处理，排除掉不需要扫描的分区，这里使用与插入时一样的算法，找到目标分区，排除没必要的分区</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (NIL != root-&gt;append_rel_list)</span><br><span class="line">  &#123;</span><br><span class="line">      Node        *parent = <span class="literal">NULL</span>;</span><br><span class="line">      parent = (Node*)linitial(root-&gt;append_rel_list);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((nodeTag(parent) == T_AppendRelInfo) &amp;&amp; get_hash_part_strategy(((AppendRelInfo*)parent)-&gt;parent_reloid) == PARTITION_STRATEGY_HASH &amp;&amp; (root-&gt;parse-&gt;jointree-&gt;quals != <span class="literal">NULL</span>))</span><br><span class="line">      &#123;</span><br><span class="line">          Relation rel = RelationIdGetRelation(((AppendRelInfo*)parent)-&gt;parent_reloid);</span><br><span class="line">          PartitionKey key = RelationGetPartitionKey(rel);</span><br><span class="line"></span><br><span class="line">          heap_close(rel, NoLock);</span><br><span class="line"></span><br><span class="line">          Const cc = *(Const*)((OpExpr*)((List*)root-&gt;parse-&gt;jointree-&gt;quals)-&gt;head-&gt;data.ptr_value)-&gt;args-&gt;head-&gt;next-&gt;data.ptr_value;</span><br><span class="line">          </span><br><span class="line">          cur_index = DatumGetUInt32(OidFunctionCall1(get_hashfunc_oid(key-&gt;parttypid[<span class="number">0</span>]), cc.constvalue)) % list_length(root-&gt;append_rel_list);</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//hash分区则进行判断</span></span><br><span class="line">          <span class="keyword">if</span> (get_hash_part_number(rte-&gt;relid) != cur_index)</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>return true;需要扫描，false不需要扫描，找到目标分区后，其他的过滤掉。</p>
<p>上面只是简单的获取 where id = 1;得到value值1，进行哈希运算寻找目标分区，还需要对where子句做更细致的处理，更多的可查看补丁。</p>
<p>目前完成以下几种的查询优化。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># explain analyze select * from h where id = 1;</span></span><br><span class="line">                                             QUERY PLAN                                             </span><br><span class="line"><span class="comment">----------------------------------------------------------------------------------------------------</span></span><br><span class="line"> Append  (cost=0.00..41.88 rows=13 width=4) (actual time=0.022..0.026 rows=1 loops=1)</span><br><span class="line">   -&gt;  Seq Scan on h3  (cost=0.00..41.88 rows=13 width=4) (actual time=0.014..0.017 rows=1 loops=1)</span><br><span class="line">         Filter: (id = 1)</span><br><span class="line">         Rows Removed by Filter: 4</span><br><span class="line"> Planning time: 0.271 ms</span><br><span class="line"> Execution time: 0.069 ms</span><br><span class="line">(6 rows)</span><br><span class="line"></span><br><span class="line">postgres=<span class="comment"># explain analyze select * from h where id = 1 or id = 20;</span></span><br><span class="line">                                             QUERY PLAN                                             </span><br><span class="line"><span class="comment">----------------------------------------------------------------------------------------------------</span></span><br><span class="line"> Append  (cost=0.00..96.50 rows=50 width=4) (actual time=0.015..0.028 rows=2 loops=1)</span><br><span class="line">   -&gt;  Seq Scan on h3  (cost=0.00..48.25 rows=25 width=4) (actual time=0.014..0.017 rows=1 loops=1)</span><br><span class="line">         Filter: ((id = 1) OR (id = 20))</span><br><span class="line">         Rows Removed by Filter: 4</span><br><span class="line">   -&gt;  Seq Scan on h4  (cost=0.00..48.25 rows=25 width=4) (actual time=0.006..0.008 rows=1 loops=1)</span><br><span class="line">         Filter: ((id = 1) OR (id = 20))</span><br><span class="line">         Rows Removed by Filter: 10</span><br><span class="line"> Planning time: 0.315 ms</span><br><span class="line"> Execution time: 0.080 ms</span><br><span class="line">(9 rows)</span><br><span class="line"></span><br><span class="line">postgres=<span class="comment"># explain analyze select * from h where id in (1,2,3);</span></span><br><span class="line">                                             QUERY PLAN                                             </span><br><span class="line"><span class="comment">----------------------------------------------------------------------------------------------------</span></span><br><span class="line"> Append  (cost=0.00..90.12 rows=76 width=4) (actual time=0.015..0.028 rows=3 loops=1)</span><br><span class="line">   -&gt;  Seq Scan on h3  (cost=0.00..45.06 rows=38 width=4) (actual time=0.014..0.018 rows=2 loops=1)</span><br><span class="line">         Filter: (id = ANY ('&#123;1,2,3&#125;'::integer[]))</span><br><span class="line">         Rows Removed by Filter: 3</span><br><span class="line">   -&gt;  Seq Scan on h4  (cost=0.00..45.06 rows=38 width=4) (actual time=0.005..0.008 rows=1 loops=1)</span><br><span class="line">         Filter: (id = ANY ('&#123;1,2,3&#125;'::integer[]))</span><br><span class="line">         Rows Removed by Filter: 10</span><br><span class="line"> Planning time: 0.377 ms</span><br><span class="line"> Execution time: 0.073 ms</span><br><span class="line">(9 rows)</span><br></pre></td></tr></table></figure>
<h2 id="备份恢复"><a href="#备份恢复" class="headerlink" title="备份恢复"></a>备份恢复</h2><p>添加hash partition之后，备份恢复时，创建分区时将分区key的信息记录到了pg_class.relpartbound，</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># create table h (id int) partition by hash(id);</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span></span><br><span class="line">postgres=<span class="comment"># create table h1 partition of h;</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span></span><br><span class="line">postgres=<span class="comment"># create table h2 partition of h;</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span></span><br><span class="line">postgres=<span class="comment"># select relname,relispartition,relpartbound from pg_class where relname like 'h%';;</span></span><br><span class="line"> relname | relispartition |                                               relpartbound                                                </span><br><span class="line"><span class="comment">---------+----------------+-----------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> h       | f              | </span><br><span class="line"> h1      | t              | &#123;PARTITIONBOUNDSPEC :strategy h :listdatums &lt;&gt; :lowerdatums &lt;&gt; :upperdatums &lt;&gt; :hashnumber <span class="number">0</span> :location <span class="number">0</span>&#125;</span><br><span class="line"> h2      | t              | &#123;PARTITIONBOUNDSPEC :strategy h :listdatums &lt;&gt; :lowerdatums &lt;&gt; :upperdatums &lt;&gt; :hashnumber <span class="number">1</span> :location <span class="number">0</span>&#125;</span><br><span class="line">(<span class="number">3</span> <span class="keyword">rows</span>)</span><br><span class="line"></span><br><span class="line">使用pg_dump时，创建分区的语句会带有<span class="keyword">key</span>值信息，导致恢复失败，</span><br><span class="line"></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Name: h; Type: TABLE; Schema: public; Owner: postgres</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> h (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">integer</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">HASH</span> (<span class="keyword">id</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> h OWNER <span class="keyword">TO</span> postgres;</span><br><span class="line"></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Name: h1; Type: TABLE; Schema: public; Owner: postgres</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> h1 <span class="keyword">PARTITION</span> <span class="keyword">OF</span> h</span><br><span class="line"><span class="built_in">SERIAL</span> <span class="built_in">NUMBER</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> h1 OWNER <span class="keyword">TO</span> postgres;</span><br><span class="line"></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Name: h2; Type: TABLE; Schema: public; Owner: postgres</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> h2 <span class="keyword">PARTITION</span> <span class="keyword">OF</span> h</span><br><span class="line"><span class="built_in">SERIAL</span> <span class="built_in">NUMBER</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> h2 OWNER <span class="keyword">TO</span> postgres;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> h1 <span class="keyword">PARTITION</span> <span class="keyword">OF</span> h <span class="built_in">SERIAL</span> <span class="built_in">NUMBER</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>这样显然是错误的，需要修改pg_dump.c ,如果是hash partition，不将partbound信息添加进去</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!(<span class="built_in">strcmp</span>(strategy, s) == <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">	appendPQExpBufferStr(q, <span class="string">"\n"</span>);</span><br><span class="line">	appendPQExpBufferStr(q, tbinfo-&gt;partbound);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="回归测试"><a href="#回归测试" class="headerlink" title="回归测试"></a>回归测试</h2><p>/src/test/regress/sql/：相关测试的sql文件</p>
<p>/src/test/regress/expected/：sql执行后的预期结果</p>
<p>/src/test/regress/results/：sql执行后的结果</p>
<p>diff 比较它们生成regression.diffs –&gt; diff expected/xxxx.out results/xxxx.out</p>
<p>Beta2上是没有hash partition的，所以创建hash partition时会有不同，需要去掉不然回归测试不通过。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- only accept "list" and "range" as partitioning strategy</span></span><br><span class="line">-<span class="keyword">CREATE</span> <span class="keyword">TABLE</span> partitioned (</span><br><span class="line">-	a <span class="built_in">int</span></span><br><span class="line">-) <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">HASH</span> (a);</span><br><span class="line">-ERROR:  unrecognized partitioning strategy "hash"</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>\d \d+</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># \d+ h*</span></span><br><span class="line">                                     Table "public.h"</span><br><span class="line"> Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description </span><br><span class="line"><span class="comment">--------+---------+-----------+----------+---------+---------+--------------+-------------</span></span><br><span class="line"> id     | integer |           |          |         | plain   |              | </span><br><span class="line">Partition key: HASH (id)</span><br><span class="line">Partitions: h1 SERIAL NUMBER 0,</span><br><span class="line">            h2 SERIAL NUMBER 1</span><br><span class="line"></span><br><span class="line">                                    Table "public.h1"</span><br><span class="line"> Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description </span><br><span class="line"><span class="comment">--------+---------+-----------+----------+---------+---------+--------------+-------------</span></span><br><span class="line"> id     | integer |           |          |         | plain   |              | </span><br><span class="line">Partition of: h SERIAL NUMBER 0</span><br><span class="line">Partition constraint: (id IS NOT NULL)</span><br><span class="line"></span><br><span class="line">                                    Table "public.h2"</span><br><span class="line"> Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description </span><br><span class="line"><span class="comment">--------+---------+-----------+----------+---------+---------+--------------+-------------</span></span><br><span class="line"> id     | integer |           |          |         | plain   |              | </span><br><span class="line">Partition of: h SERIAL NUMBER 1</span><br><span class="line">Partition constraint: (id IS NOT NULL)</span><br></pre></td></tr></table></figure>
<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><h3 id="不支持-attach、detach"><a href="#不支持-attach、detach" class="headerlink" title="不支持 attach、detach"></a>不支持 attach、detach</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># create table h3 (id int);</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span></span><br><span class="line">postgres=<span class="comment"># alter table h attach partition h3;</span></span><br><span class="line"><span class="keyword">ERROR</span>:  <span class="keyword">hash</span> <span class="keyword">partition</span> <span class="keyword">do</span> <span class="keyword">not</span> support attach operation</span><br><span class="line">postgres=<span class="comment"># alter table h detach partition h2;</span></span><br><span class="line"><span class="keyword">ERROR</span>:  <span class="keyword">hash</span> <span class="keyword">partition</span> <span class="keyword">do</span> <span class="keyword">not</span> support detach operation</span><br></pre></td></tr></table></figure>
<h3 id="不支持-drop-分区子表"><a href="#不支持-drop-分区子表" class="headerlink" title="不支持 drop 分区子表"></a>不支持 drop 分区子表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># drop table h2;</span></span><br><span class="line">ERROR:  hash partition "h2" can not be dropped</span><br></pre></td></tr></table></figure>
<p>outfunc.c readfunc.c copyfunc.c</p>
<h2 id="邮件列表"><a href="#邮件列表" class="headerlink" title="邮件列表"></a>邮件列表</h2><p><a href="https://www.postgresql.org/message-id/2017082612390093777512%40highgo.com" target="_blank" rel="noopener">https://www.postgresql.org/message-id/2017082612390093777512%40highgo.com</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="Yang Jie"
    src="/images/head.jpg">
  <p class="site-author-name" itemprop="name">Yang Jie</p>
  <div class="site-description" itemprop="description">Stay hungry, Stay young</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yonj1e" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;yonj1e" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yonj1e@163.com" title="E-Mail &amp;rarr; mailto:yonj1e@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yang Jie</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.4.2
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.2"></script><script src="/js/motion.js?v=7.4.2"></script>
<script src="/js/schemes/pisces.js?v=7.4.2"></script>
<script src="/js/next-boot.js?v=7.4.2"></script><script src="/js/bookmark.js?v=7.4.2"></script>



  


















  

  

  

</body>
</html>
